<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
		 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' lang='utf-8' xml:lang='utf-8'>
<head>
<title>Talkback:164/lg_tips.html#1</title>
<meta http-equiv='Content-Type; charset=utf-8' />
<link rel='stylesheet' type='text/css' href='../../../lg.css' />
</head>
<body>
<a href="../../../"><img alt="Linux Gazette" src="../../../gx/2003/newlogo-blank-200-gold2.jpg" id="logo" /></a><img alt="Tux" src="../../../gx/tux_86x95_indexed.png" id="tux" /><p id="fun">...making Linux just a little more fun!</p><div class='content articlecontent'><a name="top"></a><h3>Talkback:164/lg_tips.html#1</h3>
<p><b>[ In reference to "<a href='../../../164/lg_tips.html'>2-Cent Tips</a>" in LG#164 ]</b></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Fri, 03 Jul 2009 23:14:47 +0200</b>
</p>

<p>
@$# This was originally entitled: "about 2c ext2 fragmentation" - Kat
$#@
</p>

<p>
On Fri, 2009-07-03 at 22:46 +0200, Carlos Baiget wrote:
</p>

<pre>
&gt; another 0.5c: If any file in the given directory has a space in his 
&gt; name, the defragmentation script will not work. To replace all spaces 
&gt; inside the file name, i suggest to do a
&gt; 
&gt;  rename 's/\ /_/g' *
&gt; 
&gt; previously or modify IFS environment variable to not consider space as 
&gt; field separator.
&gt; 
&gt; Carlos
</pre>


<p>
Ah, yes;  or simply quote the file names as follows:
</p>

<pre>
    fs=`echo "$line" | cut -f 1 -d':'`
    fn=`echo "$line" | cut -f 2 -d':'`
# copy the file up to 10 times, preserving permissions
    j=0;
    while [ -f "$fn" -a $j -lt 10 ]; do
    ....
</pre>

<p>
IFS also makes sense.  Thanks for highlighting this rather serious error.  I 
really should have taken the trouble to test this properly first!
</p>

<p>
Paul
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Fri, 03 Jul 2009 23:17:55 +0200</b>
</p>

<p>
Aaaahhhh!  Top posted!  Too late, she cried!
</p>

<p>
<p class="editorial">
[[[  It's okay, Paul - for you, I manually corrected it. Thanks for
noticing and caring.  -- Kat  ]]]
</p>

</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Fri, 3 Jul 2009 22:24:27 +0100</b>
</p>

<p>
2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
</p>

<pre>
&gt; Ah, yes;  or simply quote the file names as follows:
&gt;
&gt;    fs=`echo "$line" | cut -f 1 -d':'`
&gt;    fn=`echo "$line" | cut -f 2 -d':'`
&gt; # copy the file up to 10 times, preserving permissions
&gt;    j=0;
&gt;    while [ -f "$fn" -a $j -lt 10 ]; do
&gt;    ....
&gt;
&gt; IFS also makes sense.  Thanks for highlighting this rather serious error.  I
&gt; really should have taken the trouble to test this properly first!
&gt;
&gt; Paul
&gt;
&gt; On Fri, 2009-07-03 at 22:46 +0200, Carlos Baiget wrote:
&gt;&gt; another 0.5c: If any file in the given directory has a space in his
&gt;&gt; name, the defragmentation script will not work. To replace all spaces
&gt;&gt; inside the file name, i suggest to do a
&gt;&gt;
&gt;&gt;  rename 's/\ /_/g' *
</pre>

<p>
Err, be careful here -- rename as a command is <strong>not</strong> the same across
distributions.  On Debian and I assume it's derivatives, it is indeed
the classic perl script.  On Redhat, it's something <strong>completely</strong>
different.  In which case "mmv" and friends can be used.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Fri, 03 Jul 2009 23:52:26 +0200</b>
</p>

<p>
On Fri, 2009-07-03 at 22:24 +0100, Thomas Adam wrote:
</p>

<pre>
&gt; 2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
&gt; &gt; On Fri, 2009-07-03 at 22:46 +0200, Carlos Baiget wrote:
&gt; &gt;&gt; another 0.5c: If any file in the given directory has a space in his
&gt; &gt;&gt; name, the defragmentation script will not work. To replace all spaces
&gt; &gt;&gt; inside the file name, i suggest to do a
&gt; &gt;&gt;
&gt; &gt;&gt;  rename 's/\ /_/g' *
&gt; 
&gt; Err, be careful here -- rename as a command is <strong>not</strong> the same across
&gt; distributions.  On Debian and I assume it's derivatives, it is indeed
&gt; the classic perl script.  On Redhat, it's something <strong>completely</strong>
&gt; different.  In which case "mmv" and friends can be used.
&gt; 
&gt; -- Thomas Adam
</pre>

<p>
Good point.  Anyway, the other problem with the script is that it needs
root privilege to run '/sbin/filefrag'.  The script is not really safe
either as pointed out by Carlos.  I have tested the following against a
directory of files that contain spaces.  On the other hand, the fact
that 'filefrag' can't be run as a normal user rather limits it's use.
chmod +s /sbin/filefrag is an option.
</p>

<p>
Can you spot any more loopholes?
</p>

<p>
<pre class='code'>
#!/bin/sh
# Retrieve a list for fragmented files, #fragments:filename
FILEFRAG="/sbin/filefrag"
if [ ! -f $FILEFRAG ]; then
  echo requires $FILEFRAG to defrag this directory
  exit 0
fi
 
flist() {
  for i in *; do
    if [ -f "$i" ]; then
      ff=`$FILEFRAG "$i"`
      fn=`echo "$ff" | cut -f1 -d':'`
      fs=`echo "$ff" | cut -f2 -d':' | cut -f2 -d' '`
      if [ -f "$fn" -a $fs -gt 1 ]; then echo -e "$fs:$fn"; fi
    fi
  done
}
IFS='
'
 
# Sort the list numeric, descending
flist | sort -n -r |
(
# for each file
  while read line; do
    fs=`echo "$line" | cut -f 1 -d':'`
    fn=`echo "$line" | cut -f 2 -d':'`
# copy the file up to 10 times, preserving permissions
    j=0;
    while [ -f "$fn" -a $j -lt 10 ]; do
      j=$[ $j + 1 ]
 
      TMP=$$.tmp.$j
      if ! cp -p "$fn" "$TMP"; then
        echo copy failed [$fn]
        j=10
      else
# test the new temp file's fragmentation, and if less than the
# original, move the temp file over the original
        ns=`$FILEFRAG $TMP | cut -f2 -d':' | cut -f2 -d' '`
        if [ $ns -lt $fs ]; then
          mv "$TMP" "$fn"
          fs=$ns
          if [ $ns -lt 2 ]; then j=10; fi
        fi
      fi
    done
    j=0;
# clean up temporary files
    while [ $j -lt 10 ]; do
      j=$[ $j + 1 ]
 
      TMP=$$.tmp.$j
      if [ -f "$TMP" ]; then
        rm "$TMP"
      else
        j=10
      fi
    done
  done
)
# report fragmentation
for i in *; do if [ -f $i ]; then $FILEFRAG $i; fi; done
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Fri, 3 Jul 2009 22:54:40 +0100</b>
</p>

<p>
2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
</p>

<pre>
&gt; Can you spot any more loopholes?
</pre>

<p>
I scanned it very quickly, you, like everyone else, needs to "USE"
""MORE"" """""QUOTES""""".
</p>

<p>
I can't stress enough just <strong>how</strong> important that is.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Sat, 04 Jul 2009 00:02:26 +0200</b>
</p>

<p>
On Fri, 2009-07-03 at 22:54 +0100, Thomas Adam wrote:
</p>

<pre>
&gt; 2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
&gt; &gt; Can you spot any more loopholes?
&gt; 
&gt; I scanned it very quickly, you, like everyone else, needs to "USE"
&gt; ""MORE"" """""QUOTES""""".
&gt; 
&gt; I can't stress enough just <strong>how</strong> important that is.
&gt; 
&gt; -- Thomas Adam
</pre>

<p>
... as in the last line, 
</p>

<pre>
   for i in *; do if [ -f $i ]; then $FILEFRAG $i; fi; done
should be
   for i in *; do if [ -f "$i" ]; then $FILEFRAG "$i"; fi; done
</pre>

<p>
oh well....
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Sat, 04 Jul 2009 00:42:41 +0200</b>
</p>

<p>
On Fri, 2009-07-03 at 22:54 +0100, Thomas Adam wrote:
</p>

<pre>
&gt; 2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
&gt; &gt; Can you spot any more loopholes?
&gt; 
&gt; I scanned it very quickly, you, like everyone else, needs to "USE"
&gt; ""MORE"" """""QUOTES""""".
&gt; I can't stress enough just <strong>how</strong> important that is.
&gt; -- Thomas Adam
</pre>

<p>
Ok, here's the latest.  Gives a bit more feedback about what is
happening in a more readable way.  Also fixes a bug that left temp files
lying around.  I'm running out of still fragmented directories/files to
test it on.
</p>

<p>
<pre class='code'>
#!/bin/sh
# Retrieve a list for fragmented files, #fragments:filename
FILEFRAG="/sbin/filefrag"
if [ ! -f $FILEFRAG ]; then
  echo requires $FILEFRAG to defrag this directory
  exit 0
fi
 
flist() {
  for i in *; do
    if [ -f "$i" ]; then
      ff=`$FILEFRAG "$i"`
      fn=`echo "$ff" | cut -f1 -d':'`
      fs=`echo "$ff" | cut -f2 -d':' | cut -f2 -d' '`
      if [ -f "$fn" -a $fs -gt 1 ]; then echo -e "$fs:$fn"; fi
    fi
  done
}
 
# Internal Field Separator is now a newline
IFS='
'
 
# Sort the list numeric, descending
echo Reading files...
flist | sort -n -r |
(
# for each file
  while read line; do
    fs=`echo "$line" | cut -f 1 -d':'`
    fn=`echo "$line" | cut -f 2 -d':'`
# copy the file up to 10 times, preserving permissions
    j=0;
    echo -e -n "$fn\t$fs"
    while [ -f "$fn" -a $j -lt 10 ]; do
      j=$[ $j + 1 ]
      echo -n "."
      TMP=$$.tmp.$j
      if ! cp -p "$fn" "$TMP"; then
        echo copy failed [$fn]
        j=10
      else
# test the new temp file's fragmentation, and if less than the
# original, move the temp file over the original
        ns=`$FILEFRAG $TMP | cut -f2 -d':' | cut -f2 -d' '`
        if [ $ns -lt $fs ]; then
          mv "$TMP" "$fn"
          fs=$ns
    	  echo -n "$fs"
          if [ $ns -lt 2 ]; then j=10; fi
        fi
      fi
    done
    echo
    echo "    - file now has $fs fragments"
    j=0;
# clean up temporary files
    while [ $j -lt 10 ]; do
      j=$[ $j + 1 ]
 
      TMP=$$.tmp.$j
      if [ -f "$TMP" ]; then
        rm "$TMP"
      fi
    done
  done
)
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Fri, 3 Jul 2009 23:50:24 +0100</b>
</p>

<p>
2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
</p>

<pre>
&gt; if [ ! -f $FILEFRAG ]; then
</pre>

<p>
<pre class='code'>
[ -x "$FILEFRAG" ]
</pre>

<p>
Just on the off-chance the file isn't executable for some odd reason.
</p>


<pre>
&gt;  echo requires $FILEFRAG to defrag this directory
</pre>

<p>
<pre class='code'>
echo "requires $FILEFRAG to defrag this directory"
</pre>


<pre>
&gt;  exit 0
&gt; fi
&gt;
&gt; flist() {
&gt;  for i in *; do
&gt;    if [ -f "$i" ]; then
&gt;      ff=`$FILEFRAG "$i"`
</pre>

<p>
To be honest, only the most <strong>ancient</strong> of shells, and I mean ancient,
won't understand:
</p>

<p>
<pre class='code'>
$()
</pre>

<p>
For command substitution, over backticks.  Given nesting backticks is
problematic, you should just use "$()".
</p>


<pre>
&gt;      fn=`echo "$ff" | cut -f1 -d':'`
&gt;      fs=`echo "$ff" | cut -f2 -d':' | cut -f2 -d' '`
&gt;      if [ -f "$fn" -a $fs -gt 1 ]; then echo -e "$fs:$fn"; fi
</pre>

<p>
Odd -- you claim "/bin/sh", yet "echo -e" isn't POSIX -- and why is it
even invoked as such here, when you're not asking for backslash
interpretation?
</p>


<pre>
&gt;    echo -e -n "$fn\t$fs"
</pre>

<p>
printf()
</p>



<pre>
&gt;      j=$[ $j + 1 ]
</pre>

<p>
((J++)) -- the square-brackets are an arcane syntax.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Sat, 04 Jul 2009 01:12:14 +0200</b>
</p>

<p>
On Fri, 2009-07-03 at 23:50 +0100, Thomas Adam wrote:
</p>

<pre>
&gt; 2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
&gt; &gt; if [ ! -f $FILEFRAG ]; then
&gt; 
&gt; ```
&gt; [ -x "$FILEFRAG" ]
&gt; '''
&gt; 
&gt; Just on the off-chance the file isn't executable for some odd reason.
</pre>

<p>
Cool.  I had changed it to -x elsewhere, but the real problem is if the
script is run as an ordinary user, the execution fails because of a
kernel access restriction.  I was thinking of checking 
</p>

<pre>
  -x $FILEFRAG -a $USER=root or
  -x $FILEFRAG -a -s $FILEFRAG.  Might be better.
</pre>


<pre>
&gt; &gt;  echo requires $FILEFRAG to defrag this directory
&gt; 
&gt; ```
&gt; echo "requires $FILEFRAG to defrag this directory"
&gt; 
&gt; &gt;  exit 0
&gt; &gt; fi
&gt; &gt;
&gt; &gt; flist() {
&gt; &gt;  for i in *; do
&gt; &gt;    if [ -f "$i" ]; then
&gt; &gt;      ff=`$FILEFRAG "$i"`
&gt; 
&gt; To be honest, only the most <strong>ancient</strong> of shells, and I mean ancient,
&gt; won't understand:
&gt; 
&gt; ```
&gt; $()
&gt; '''
</pre>

<p>
... you can tell I'm rather ancient, can't you?  I have never used $()
before, other than in makefiles...
</p>


<pre>
&gt; For command substitution, over backticks.  Given nesting backticks is
&gt; problematic, you should just use "$()".
&gt; 
&gt; &gt;      fn=`echo "$ff" | cut -f1 -d':'`
&gt; &gt;      fs=`echo "$ff" | cut -f2 -d':' | cut -f2 -d' '`
&gt; &gt;      if [ -f "$fn" -a $fs -gt 1 ]; then echo -e "$fs:$fn"; fi
&gt; 
&gt; Odd -- you claim "/bin/sh", yet "echo -e" isn't POSIX -- and why is it
&gt; even invoked as such here, when you're not asking for backslash
&gt; interpretation?
&gt; 
&gt; &gt;    echo -e -n "$fn\t$fs"
&gt; 
&gt; printf()
</pre>

<p>
printf() is POSIX?  I didn't know.  Agreed, echo -e is unnecessary in
the first instance.  I'll just make it #bin/bash rather, or as you
suggest, try printf() instead.
</p>


<pre>
&gt; 
&gt; &gt;      j=$[ $j + 1 ]
&gt; 
&gt; ((J++)) -- the square-brackets are an arcane syntax.
</pre>

<p>
I'm not just ancient, but a bit arcane too <img src="../gx/smile.png" alt=":-)">
</p>


<pre>
&gt; -- Thomas Adam
</pre>

<p>
Thanks, Thomas.  Your help is appreciated.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Paul Sephton [paul at inet.co.za]

</p>
</b><br />
<b>Sat, 04 Jul 2009 10:38:59 +0200</b>
</p>

<p>
On Fri, 2009-07-03 at 23:50 +0100, Thomas Adam wrote:
</p>

<pre>
&gt; 2009/7/3 Paul Sephton &lt;paul@inet.co.za&gt;:
&gt; &gt; if [ ! -f $FILEFRAG ]; then
&gt; 
&gt; ```
&gt; [ -x "$FILEFRAG" ]
&gt; '''
&gt; 
&gt; Just on the off-chance the file isn't executable for some odd reason.
</pre>

<p>
&lt;snip&gt;
Ok, this actually reads and works a whole lot better.  Thanks for the
tips, Thomas:
</p>

<pre>
#!/bin/sh
# Retrieve a list for fragmented files, #fragments:filename
FILEFRAG="/sbin/filefrag"
if [ ! -x $FILEFRAG ]; then
  echo requires $FILEFRAG to defrag this directory
  exit 0
fi
if [ ! "$USER" = "root" ]; then
  if [ ! -u $FILEFRAG ]; then
    echo $FILEFRAG can only be run as root, or should be SUID root
    exit 0
  fi
fi
 
flist() {
  for i in *; do
    if [ -f "$i" ]; then
      ff=$( $FILEFRAG "$i" )
      fn=$( echo "$ff" | cut -f1 -d':' )
      fs=$( echo "$ff" | cut -f2 -d':' | cut -f2 -d' ' )
      if [ -f "$fn" -a $fs -gt 1 ]; then printf "$fs:$fn\n"; fi
    fi
  done
}
 
# Internal Field Separator is now a newline
IFS='
'
 
# Sort the list numeric, descending
echo Reading files...
flist | sort -n -r |
(
# for each file
  while read line; do
    fs=$( echo "$line" | cut -f 1 -d':' )
    fn=$( echo "$line" | cut -f 2 -d':' )
# copy the file up to 10 times, preserving permissions
    j=0
    printf "$fn\t$fs"
    while [ -f "$fn" -a $j -lt 10 ]; do
      ((j++))
      printf "."
      TMP=$$.tmp.$j
      if [ -f "$TMP" ]; then
        echo "Error! target temp file already exists!"
      elif ! cp -p "$fn" "$TMP"; then
        echo copy failed [$fn]
        j=10
      else
# test the new temp file's fragmentation, and if less than the
# original, move the temp file over the original
        ns=$( $FILEFRAG "$TMP" | cut -f2 -d':' | cut -f2 -d' ' )
        if [ $ns -lt $fs ]; then
          mv "$TMP" "$fn"
          fs=$ns
    	  printf "$fs"
          if [ $ns -lt 2 ]; then j=10; fi
        fi
      fi
    done
    echo
    echo "    (file now has $fs fragments)"
    j=0
# clean up temporary files
    while [ $j -lt 10 ]; do
      ((j++))
 
      TMP=$$.tmp.$j
      if [ -f "$TMP" ]; then
        rm "$TMP"
      fi
    done
  done
)
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_talkback.html#mb-talkback_164_lg_tips_html_1">Back</a><hr width="50%" align="left" /><p><br /></p></div>
</body>
</html>