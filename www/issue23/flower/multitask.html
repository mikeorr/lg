<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Generator" CONTENT="Microsoft Word 97">
   <META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.01b6C [en] (X11; I; Linux 2.1.47 i486) [Netscape]">
   <TITLE>Processes and Process Context</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#800080">
<FONT COLOR="#3366FF"><FONT SIZE=+3><B>Multitasking</B></FONT></FONT>

<P><FONT SIZE=+1>It would be extremely inefficient for a single process
to have complete use of the processor from the time of its start-up to
the completion of its operations. One reason for this is that most processes
must pause very often to wait for input such as data from I/O devices,
keyboard input or disk accesses. In the simplest case therefore a large
amount of useable CPU time would be wasted due to this blocking. This would
result in a large overall time to carry out a number of independent tasks.
The processor must also handle asynchronous software or hardware interrupts
which may require high priority service for a short period, requiring the
currently active process to be displaced from the processor while the interrupt
is handled before normal processing can be resumed. Such interrupts may
be caused by events such as an input buffer becoming full which, if not
serviced in a timely manner could result in an unrecoverable loss of data.</FONT>

<P><FONT SIZE=+1>To increase throughput efficiency most modern operating
systems implement a method to allow many processes to be available for
running at any one time. Their access to the processor is interleaved and,
as the speed of modern processors is high compared to slower I/O devices,
it is possible to provide a pseudo real-time response to an active user
of the system for any particular process when in reality many processes
are being run. The total time to complete a number of tasks will also be
less due to less time being wasted waiting for external inputs. Interrupt
handling is facilitated as well as this round robin scheduling of normal
processes.</FONT>

<P><FONT SIZE=+1>This procedure is known as Multitasking (or Multiprogramming)
and its sequencing is controlled by an operating system service called
the scheduler. Some operating systems (e.g. Windows 3.1) just rely on the
process itself giving up the processor at regular intervals or when waiting
on I/O. This approach is known as co-operative multitasking and it can
have many problems as, if the process does not give up the CPU at the expected
time failure can occur. In this case all other processes will be blocked
and there will be no way for the operating system to gain control of the
processor, most likely resulting in a system lockup or crash.</FONT>

<P><FONT SIZE=+1>A better approach, and that used in most operating systems
designed for efficient multitasking is that of <I>pre-emptive multitasking
. </I>In this case it is the operating system that decides which process
gets access to the CPU. It can allocate CPU time to a process or remove
the process from the CPU as required. Each candidate process gets access
to the CPU for a short time (known as a quantum) based on their allocated
priority, their process class and also their voluntary release of the processor
as they wait for external input.</FONT>
<DIV ALIGN=right>&nbsp;</DIV>

<DIV ALIGN=right></DIV>

<DIV ALIGN=right><A HREF="groups.html"><IMG SRC="../gx/flower/cyan_lef.gif"
BORDER=0 HEIGHT=31 WIDTH=31></A><A HREF="page1.html"><IMG
SRC="../gx/flower/cyan_up.gif" BORDER=0 HEIGHT=31 WIDTH=31></A><A
HREF="multiproc.html"><IMG SRC="../gx/flower/cyan_rig.gif" BORDER=0 HEIGHT=31 WIDTH=31></A></DIV>
&nbsp;
<BR>&nbsp;

<P>&nbsp;
<BR>&nbsp;

<P>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
</BODY>
</HTML>
