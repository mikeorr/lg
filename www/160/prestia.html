<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="utf-8" xml:lang="utf-8">
<head>
<title>Joey's Notes: Bash shell basics LG #160</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../lg.css" type="text/css" media="screen, projection"  />
<link rel="alternate" type="application/rss+xml" title="LG RSS" href="lg.rss" />
<link rel="alternate" type="application/rdf+xml" title="LG RDF" href="lg.rdf" />
<!-- link rel="alternate" type="application/atom+xml" title="LG Atom" href="lg.atom.xml" / -->
<link rel="shortcut icon" href="../favicon.ico" />

<style type="text/css" media="screen, projection">
<!--

-->
</style>

</head>
<body>

<a href="../">
<img src="../gx/2003/newlogo-blank-200-gold2.jpg" id="logo" alt="Linux Gazette"/>
</a>
<p id="fun">...making Linux just a little more fun!</p>

<div id="navigation">
<table summary="masthead" width="100%">
<tr>
<td align="center" colspan="3" style="font-size: 10px; font-weight: bold">
<a href="../index.html">Home</a>
<a href="http://linuxgazette.net">Main Site</a>
<a href="../faq/index.html">FAQ</a>

<a href="../lg_index.html">Site Map</a>
<a href="../mirrors.html">Mirrors</a>
<a href="../mirrors.html">Translations</a>
<a href="../search.html">Search</a>
<a href="../archives.html">Archives</a>
<a href="../authors/index.html">Authors</a>
<a href="http://lists.linuxgazette.net/mailman/listinfo/">Mailing Lists</a>
<a href="../jobs.html">Join Us!</a>
<a href="../contact.html">Contact Us</a>

<hr width="99%" style="border: 1px inset #000033">
</td>
</tr>
<tr>
<td width="40%" align="left" style="font-size: 10px; font-weight: bold">
The Free International Online Linux Monthly
</td>
<td width="20%" align="center" style="font-size: 10px; font-weight: bold">
ISSN: 1934-371X
</td>
<td width="40%" align="right" style="font-size: 10px; font-weight: bold">
Main site: <a href="http://linuxgazette.net">http://linuxgazette.net</a> 
</td>
</table>
</div>


<div id="breadcrumbs1">

<a href="../index.html">Home</a> &gt; 
<a href="index.html">March 2009 (#160)</a> &gt; 
Article

</div>

<div class="articlecontent1">
<div class="content">

<div id="previousnexttop">
<A HREF="okopnik.html" >&lt;-- prev</A> | <A HREF="tanaka-okopnik.html" >next --&gt;</A>
</div>

<h1>Joey's Notes: Bash shell basics</h1>
<p id="by"><b>By <a href="../authors/prestia.html">Joey Prestia</a></b></p>

<img src="../gx/minilogos/joeys_notes.png" alt="Joey's Notes image" align="left" />

<p>
It is often said that the real power of Linux lies at the command line -
and this is true. Unfortunately, many new Linux users start out trying
Linux as a desktop operating system and get frustrated when they discover
the frequent necessity of using the command line - an unfamiliar and thus
uncomfortable environment. This usually happens when they need to install
from a tarball (compileable source code in a tar.gz file) and discover that
they have to type commands or navigate to a specific directory. To make
matters worse, the directory-separator slash (/) is the wrong way if
they're used to DOS.
</p>

<p>
Or perhaps they need to get video playback to work right - something that
can still be quite challenging under Linux. These types of things can be
quite difficult for new users because of numerous differences in the
operating systems. My purpose here is to try to make the transition easier
by explaining some basics that should help, whether you are trying to learn
Linux formally or just starting out as a desktop user trying to break away
from Microsoft. 
</p>

<p>
In reality, Linux will become a whole lot easier if you get familiar with
just a few key concepts. Among those things is the directory structure: for
example, there's no more C:\ drive. Instead, Linux has the <em>root of the
file system</em> located at '/', which is equivalent to C:\ in Windows.  No
matter how many drives there are in a Linux system, there will only be one
filesystem tree - more drives just increase the available space. Linux does
not use the concept of one directory tree for each drive like Windows does.
</p>

<p>
Learning the structure of this directory tree is one of the biggest hurdles
for the new user. As an example, the part of the system containing your
personal files is referred to as your home directory; its name is the same
as your username, and it is located under the '/home' directory. There is a
link to a great little tutorial at the end of this article that may take a
couple of hours to go through, but it will definitely help you to get
familiar with Linux. 
</p>

<p>
Most commands in Linux are some short form of what the command does; e.g.,
the <tt>ls</tt> command stands for 'list', and <tt>cd</tt> being short for
change directory. Just by learning a few simple commands you will be able
to navigate your system effectively and perform many tasks, but be patient
- it takes time. Linux has around 3000+ commands.
</p>

<p class="editorial">
[ Actually, that statement is both true and misleading. Every program in
Linux is a command, but you only need to know a tiny percentage of these to
work on the command line effectively. In general, the standard Unix toolkit
(e.g., <a
href="http://www.dataexpedition.com/~sbnoble/Tips/2commands.html">this
list</a> of commands) is all that's necessary - and even experts are
rarely completely familiar with all of these. In my opinion, knowing
about 40 of these commands will suffice the average user 99.9% of the time. -- Ben ]
</p>

<p>
All of these have similarities in their syntax, and there are some basic
concepts that are uniform across all commands. Perhaps the most important
thing to remember is the <tt>man</tt> command; whenever you need to use
some unfamiliar command, just type <tt>man <em>command</em></tt>. This will
pop up the <em>manual page</em> for that command, giving you information
that you may need before you execute it.
</p>


<h3>Syntax</h3>

<p>
The syntax of a command refers to the grammar of the sequence that we enter
on the command line. To verify the syntax for a specific command, a quick
glimpse at the appropriate man page will usually clear things up; this
information is found under the SYNOPSIS heading. For most commands, the
syntax is '<strong><em>command options argument</em></strong>'.
</p>

<dl>
<dt><strong>Command</strong></dt> 
<dd>The name of a program like <tt>ls</tt> or <tt>cat</tt> or <tt>grep</tt>.</dd>

<dt><strong>Option</strong></dt>
<dd>A letter or a word preceded by a dash for "short options" or double
dashes for the "long form" of an option. <tt>-a</tt> is a short option and
<tt>--all</tt> is a long option; both mean the same thing.</dd> 

<dt><strong>Argument</strong></dt>
<dd>An argument may be a file name, a directory, a device specification
like <tt>/dev/cdrom</tt>. It is usually tied to the option (e.g., '--file
doc.txt') and is, in a sense, the object of the command.
</dd> 
</dl>

<p>
Most people have problems deciding where to put a space in the command
line. The best guideline is that there should be spaces after every command
and between all options preceded by a minus. Arguments may or may not
require preceding spaces. Again, the man page is often the best guide.
</p>


<h3>The Prompt</h3>

<p>
The first thing you'll see when working in the command shell is 
the shell prompt. Looking at it will normally tell you what user you are, 
your system hostname, and your location on the system.
</p>

<p class="editorial">
[ This is not necessarily true on many other Unix systems, or even in some
of the smaller Linux distros. Often, the prompt consists of nothing more
than '$', '%', or '#' to show your user level and shell type; for more
information, you may need to either configure the prompt or use some of the
toolkit informational commands. -- Ben ]
</p>

<p>
Looking at the sample below, we can see that our username is 'tom'. This is
followed by the @ symbol which separates the username from the system
hostname; if you never named your system, it may have 'localhost' in this
position. Following this, we have the '~' character which indicates that we
are in this user's home directory. Finally, we have the '$' character; this
tell us, in a general fashion, the level of permissions that we have as a
user. This varies across different shells; for example, the C shells (csh,
tcsh) will use '%' for a standard user, while the Bourne shell and its
derivatives (sh, ksh, bash, zsh, and a number of others) will usually use
'$'. The root user (the system's superuser) gets a special prompt of '#';
this lets the user know to be very, very cautious and precise in the
commands they issue, since the root user can easily destroy or damage the
system.
</p>

<p>
<strong>Regular User:</strong>
</p>
<pre class="code">
[tom@station1 ~]$            
</pre>
<p>
<strong>Root User:</strong>
</p>
<pre class="code">
[root@station1 ~]#
</pre>

<p>
Typing the command <tt>echo $SHELL</tt> tom finds out he is using Bash
(a.k.a., the "Bourne Again Shell".) The 'echo' command in this example
prints the value of the <tt>$SHELL</tt> variable to the screen. The Bash
shell is normally the default shell on most modern Linux systems.
</p>

<pre class="code">
[tom@station1 ~]$ echo $SHELL
/bin/bash
</pre>

<p>
If the current directory is not shown in the prompt, the first important
command you should learn is <tt>pwd</tt> which is short for "print working
directory". This will reveal the full path as we can see below.
</p>

<pre class="code"> 
[tom@station1 ~]$ pwd
/home/tom
</pre>

<h3>Commands</h3>

<p>
Commands are either shell built-ins, compiled executable programs, or
executable scripts located somewhere on your system. The shell is a command
interpreter which reads certain environment variables (you can see these by
typing 'env' at the command line) when you open a command shell. When you
type a command, the command interpreter will search the directories listed
in the PATH variable to find the program you've asked it to execute. If it
is not a shell built-in, an alias to a command, a defined function, or a
program in the defined path, the command interpreter returns the
'command not found' error.
</p>

<pre class="code">
[tom@station1 ~]$ print help me 
bash: print: command not found
</pre>

<p>
There are many commands - maybe too many. To see how many you have
available, just hit the 'tab' key twice in a terminal; this will show you a
number and ask if you actually want to see all of them.  Don't worry:
you'll never need to know most of them (many of these are invoked by other
commands or via GUI menus.) No one can remember them all - there wouldn't
be any point to it in the first place - and learning just a handful will
help you out greatly on any Linux system.
</p>

<p>
Commands are case sensitive and are normally lower case. Another important
thing to remember is that many commands (e.g., copying, moving, attaching a
device, etc.) work in a "what to where" fashion:
</p>

<pre class="code">
cp /my/source/file /destination/file/or/directory
mv /from/here /to/there
mount /dev/mydevice /directory/to/mount/in
</pre>


<h3>Switches and Options</h3> 

<p>
Switches and options are used to modify the action of the command. They are
usually preceded immediately by either a single or double dash, and are in
the form of letters or full words. Some commands will require options and
some will not. Here are some samples: 
</p>

<p>
Simple command:
</p>
<pre class="code">
[tom@station1 ~]$ ls
</pre>
<p>
Short option example:
</p>
<pre class="code">
[tom@station1 ~]$ ls -a
</pre>
<p>
Multiple short options: 
</p>
<pre class="code">
[tom@station1 ~]$ ls  -a -h -i
</pre>
<p>
Multiple short options can be grouped:
</p>
<pre class="code">
[tom@station1 ~]$ ls -ahi
</pre>
<p>
Long option example:
</p>
<pre class="code">
[tom@station1 ~]$ ls --all 
</pre>
<p>
Multiple long options:
</p>
<pre class="code">
[tom@station1 ~]$ ls --all --human-readable --inode
</pre>

<p>
Normally, short options can be grouped together if more than one is
required. In addition, some short options have equivalent long options
which perform the same action.   
</p>

<h3>Arguments</h3>

<p>
An argument is usually an object that the command operates on; whether a
command takes an argument at all depends on the command. For example, the
command <tt>ls</tt> can take an argument, but if none is supplied the
command assumes the current working directory is the argument and lists the
current directory. An example of a command that takes no arguments is
'true': it takes only options.

<!-- Changed 'top' to 'true'. Joey, 'top' does indeed take arguments: e.g.,
'top -p pid [,pid, ...]' is valid usage. - Ben -->

Again, arguments vary depending on the command and a great many commands
have a default argument. 
</p>


<h3>Getting Help Using the Man Pages</h3>

<p>
When using the command line,  it is advantageous to get in the habit of
using Linux's built-in manual page system, also called the "man" pages. At
first glance, the man pages can look intimidating and very cryptic. Be
assured, though - they are very helpful and necessary.  By using them you
will greatly enhance the speed at which you are learning Linux.  To see
the man pages for a command, merely type 'man command' and a screen with
information will pop up. To navigate a man page, you use the arrow keys
and page-up/page-down keys to scroll, and the letter "q" to quit. There are
a number of other navigation keys for searching, jumping to the top or the
bottom, and so on; these depend on the pager program (usually 'more' or
'less', with the latter being most common.) You can read about these by
hitting the 'h' key (help) while browsing the man page.
</p>

<p>
When you look at any man page, you will notice several section headings:
</p>

<dl>
<dt><strong>NAME:</strong></dt> 
<dd>The name of the command and often similar commands that may be of use.</dd>

<dt><strong>SYNOPSIS:</strong></dt> 
<dd>This section will give you the detailed syntax for running the command
correctly. You may have to review the OPTIONS section, below, to get the
precise details. There are many commands that must have options supplied to
work at all.</dd> 

<dt><strong>DESCRIPTION:</strong></dt>
<dd>Usually a brief to detailed technical description of what 
the command does.</dd> 

<dt><strong>OPTIONS:</strong></dt> 
<dd>Under this heading, there will be a listing of the long and short
options that the command accepts. You will almost always need to use some
sort of option with a command, so this section is quite important.  This
section can be fairly long. Since most commands use different meanings for
their options, be aware that whatever options you used on one command may
mean something completely different when used with some other command.</dd>

<dt><strong>EXAMPLES:</strong></dt> 
<dd>When using unfamiliar commands I almost always look for this section so I 
don't foul something up. This section, if it exists, may further clarify up 
the syntax of the command being researched.</dd>
</dl>

<p>
There may be more categories for some commands and less for others. This 
depends on the commands.
</p>

<p>
Learning Linux can be a long process but you will most definitely find it 
fun and rewarding as you discover the awesome power that it contains.   
</p>

<h3>Additional Help</h3> 

<p>
The Linux system was originally designed for the command line user, and if
you know how to find the help that you need, you will have access to far
more power than the average desktop user can even imagine.

<!-- Snipped poor example of 'updatedb' and 'makewhatis'. The 'Find' dialog
in Windows does that just as efficiently, and is perhaps easier for the
average user. In addition, both 'updatedb' and 'makewhatis' are usually an
automatic part of most distros, as well as being part of regular
maintenance handled by 'cron' files. - Ben -->

Another helpful source of information, if it is installed on your machine,
is the 'info' command; this is the Texinfo documentation system, which
contains the official documentation of the GNU Project. Some systems have
both 'man' and 'info' available. It is a good idea to check both and see if
one offers more information that is to your liking.  Generally info pages
tend to be easier to understand then the man pages, although in some
instances the information is identical. To use the info system, type
<tt>info <em>command</em></tt> or just <tt>info</tt> to get familiar with
it.
</p>

<h3>Tab Completion</h3>

<p>
Another helpful feature of the Linux command line is <em>tab command
completion</em> and <em>path completion</em>. If you are not sure of the
correct complete spelling of a command or a file name you can just type a
couple of the initial letters of that command and hit the 'tab' key to see
what the Bash shell comes up with for assistance. If the command specified
by what you've typed so far is unique, it will complete the task for you by
filling in the spelling; if not, it will present you with a list of
possible choices. 
</p>

<p>
Assuming, for example, that you need a command that can help you configure
your sound card but only remember that it starts with "syst". Just
type 
</p>

<pre class="code"> 
[tom@station1 ~]$ syst
</pre>

<p>
Then hit tab (you may need to hit it twice depending on your configuration)
which should reward you with the following output: 
</p>

<pre class="code"> 
system-cdinstall-helper          system-config-rootpassword
system-config-authentication     system-config-samba
system-config-date               system-config-securitylevel
system-config-display            system-config-securitylevel-tui
system-config-kdump              system-config-selinux
system-config-keyboard           system-config-services
system-config-language           system-config-soundcard
system-config-lvm                system-config-time
system-config-network            system-config-users
system-config-network-cmd        system-control-network
system-config-packages           system-install-packages
system-config-printer            systool
</pre>

<p>
From this, you can see the name of the command you need:
<tt>system-config-soundcard</tt>. This also works with paths to files.  To
use this feature and get the feel of how it works, start by typing a
directory path - but after typing a couple of characters hit the tab key
and see if it auto-completes for you. If it does not, it's because there is
not enough characters to differentiate it from another possible choice. You
can try adding another character or couple of characters and hitting the
tab key again; this will allow it to complete for you. This can actually
save you a lot of typing:
'cat&nbsp;/usr/include/c++/4.0.4/i486-linux-gnu/bits/messages_members.h' becomes
'cat /u&rArr;i&rArr;c+&rArr;&rArr;0.&rArr;i&rArr;b&rArr;m&rArr;' - 22 characters
instead of 66!
</p>

<h3>Command History</h3>

<p>
Using the arrow keys also can make things easier. In Bash, these are mapped
to what is called the <em>command history</em>: using the up arrow will
take you to the previous executed command, and hitting the up arrow twice
will take you back two commands. Of course, the down arrow does the
opposite and moves you forward in the command history until no more
commands are left. To see everything in the command history type
<tt>history</tt> on the command line; recalling a previous command anywhere
in the list can be done with 'Ctrl-R' and typing a part of that command.  A
command can also be recalled by noting its number in the 'history' output
and typing an exclamation point followed by that number.  There are many
more shortcuts available; you can read about these in the 'HISTORY' section
of 'man bash'.
</p>
     

<h3>Some basic commands and common switches</h3>

<table border="8" bgcolor="#c0c0c0" summary="Common Linux commands">
<tr><th>Command</th><th>Description</th><th>Common Options</th><th>Description</th></tr>

<tr><td><strong>pwd</strong></td><td>Print working directory</td><td>--help</td><td>Display help information</td></tr>

<tr><td><strong>man</strong></td><td>Display manual page</td><td>[1-8] </td><td>Man page section number</td></tr>
<tr><td> </td><td> </td><td>	-a		</td><td>All relevant information</td></tr>
<tr><td> </td><td> </td><td>-k </td><td>Keyword</td></tr> 

<tr><td><strong>cd</strong></td><td>Change directory</td><td>..</td><td>Up one level</td></tr>
<tr><td></td><td></td><td>/</td><td>Root of filesystem</td></tr>
<tr><td></td><td></td><td>~ or nothing</td><td>Current users home directory</td></tr>

<tr><td><strong>ls</strong></td><td>List files</td><td>-a --all</td><td>All even hidden files</td></tr>
<tr><td></td><td></td><td>-l</td><td>Long listing</td></tr>
<tr><td></td><td></td><td>-h --human-readable</td><td>Human readable sizes</td></tr>

<tr><td><strong>cp</strong></td><td>Copy files</td><td>-i --interactive</td><td>Prompt before overwrite</td></tr>
<tr><td></td><td></td><td>-r --recursive</td><td>Include underlying directories</td></tr>
<tr><td></td><td></td><td>-a --archive</td><td>Archive mode all files </td></tr>

<tr><td><strong>mv</strong></td><td>Move files</td><td>-i --interactive</td><td>prompt before overwrite </td></tr>
<tr><td></td><td></td><td>-u --update</td><td>move if file is newer</td></tr>
<tr><td></td><td></td><td>-f --force</td><td>Don't prompt before overwriting</td></tr>

<tr><td><strong>rm</strong></td><td>Remove files</td><td>-r --recursive</td><td>Include underlying directories</td></tr>
<tr><td></td><td></td><td>-f --force</td><td>Don't prompt before removal</td></tr>
<tr><td></td><td></td><td>-i --interactive</td><td>Prompt before removal</td></tr>

<tr><td><strong>mkdir</strong></td><td>Make directory</td><td>-p --parents</td><td>Make parent directories</td></tr>
<tr><td></td><td></td><td>-m --mode=MODE</td><td>Set file mode</td></tr>
<tr><td></td><td></td><td>-v --verbose</td><td>Print confirmation</td></tr>

<tr><td><strong>rmdir</strong></td><td>Remove directory</td><td>-p --parents</td><td>Remove directory and parents</td></tr>
<tr><td></td><td></td><td>-v --verbose</td><td>Print confirmation</td></tr>
<tr><td></td><td></td><td>--ignore-fail-on-non-empty</td><td>Ignore failure if files exist</td></tr>

<tr><td><strong>cat</strong></td><td>Concatenate files</td><td>-b --number-nonblank</td><td>Number the non blank lines</td></tr>
<tr><td></td><td></td><td>-n --number</td><td>Number all lines</td></tr>
<tr><td></td><td></td><td>-s --squeeze-blank</td><td>Only show one blank line</td></tr>

<tr><td><strong>locate</strong></td><td>Locate files</td><td>-c --count</td><td>Count matches instead</td></tr>
<tr><td></td><td></td><td>-i --ignore-case</td><td>Be case insensitive</td></tr>
<tr><td></td><td></td><td>-S --statistics</td><td>Locate database statistics</td></tr>

<tr><td><strong>less</strong></td><td>Show one page at a time</td><td>-N --LINE-NUMBERS</td><td>Print line numbers</td></tr>
<tr><td></td><td></td><td>-s --squeeze-blank-lines</td><td>Display only one blank line</td></tr>
<tr><td></td><td></td><td>-E --QUIT-AT-EOF</td><td>Make less stop at the last page</td></tr>

<tr><td><strong>grep</strong></td><td>Print lines matching a pattern</td><td>-i --ignore-case</td><td>Ignore case sensitivity</td></tr>
<tr><td></td><td></td><td>-R -r --recursive</td><td>Read all files under directory</td></tr>
<tr><td></td><td></td><td>-v --invert-match</td><td>Select non-matching lines</td></tr>

<tr><td><strong>mount</strong></td><td>Mount a device</td><td>-o</td><td>Specify additional options</td></tr>
<tr><td></td><td></td><td>-t</td><td>Manually specify file system type</td></tr>
<tr><td></td><td></td><td>-a</td><td>Mount all file systems in fstab</td></tr>

<tr><td><strong>umount</strong></td><td>Unmount a device</td><td>-t</td><td>Specify file system type</td></tr>
<tr><td></td><td></td><td>-v</td><td>Verbose mode</td></tr>
<tr><td></td><td></td><td>-r</td><td>On failure remount read olny</td></tr>
</table>

<h3>Resources</h3>

<ul>
<li><a href="http://www.linuxcommand.org/learning_the_shell.php">Learning the Shell Tutorial</a>
<li><a href="http://www.pathname.com/fhs/">The Filesystem Hierachy Standard</a></li>
</ul>				

<br clear="all" />

<script type='text/javascript'>
digg_url = 'http://linuxgazette.net/160/prestia.html';
digg_title = 'Joey\'s Notes: Bash shell basics';
digg_bodytext = '<p> It is often said that the real power of Linux lies at the command line - and this is true. Unfortunately, many new Linux users start out trying Linux as a desktop operating system and get frustrated when they discover the frequent necessity of using the command line - an unfamiliar and thus uncomfortable environment. This usually happens when they need to install from a tarball (compileable source code in a tar.gz file) and discover that they have to type commands or navigate to a specific directory. To make matters worse, the directory-separator slash (/) is the wrong way if they\'re used to DOS. </p> ';
digg_topic = 'linux_unix';
</script>
<script src="http://digg.com/tools/diggthis.js" type="text/javascript"></script>


<p class="talkback">
Talkback: <a
href="mailto:tag@lists.linuxgazette.net?subject=Talkback:160/prestia.html">Discuss this article with The Answer Gang</a>
</p>

<!-- *** BEGIN author bio *** -->
<hr>
<p>
<img align="left" alt="[BIO]" src="../gx/authors/prestia.jpg" class="bio">
</p>

<em>
<p>
Joey was born in Phoenix and started programming at the age fourteen on
 a Timex Sinclair 1000. He was driven by hopes he might be able to do
 something with this early model computer. He soon became proficient in
 the BASIC and Assembly programming languages. Joey became a programmer
 in 1990 and added COBOL, Fortran, and Pascal to his repertoire of
 programming languages. Since then has become obsessed with just about
 every aspect of computer science. He became enlightened and discovered
 RedHat Linux in 2002 when someone gave him RedHat version six. This 
 started off a new passion centered around Linux. Currently Joey is 
 completing his degree in Linux Networking and working on campus
 for the college's RedHat Academy in Arizona. He is also on the staff of
 the Linux Gazette as the Mirror Coordinator.
</p>



</em>

<br clear="all">


<!-- *** END author bio *** -->

<div id="articlefooter">

<p>
Copyright &copy; 2009, Joey Prestia. Released under the <a
href="http://linuxgazette.net/copying.html">Open Publication License</a>
unless otherwise noted in the body of the article. Linux Gazette is not
produced, sponsored, or endorsed by its prior host, SSC, Inc.
</p>

<p>
Published in Issue 160 of Linux Gazette, March 2009
</p>

</div>

<div id="previousnextbottom">
<A HREF="okopnik.html" >&lt;-- prev</A> | <A HREF="tanaka-okopnik.html" >next --&gt;</A>
</div>

</div>
</div>

<script src="http://www.google-analytics.com/urchin.js"
type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1204316-1";
urchinTracker();
</script>







<img src="../gx/tux_86x95_indexed.png" id="tux" alt="Tux"/>

</body>
</html>

