<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'
		 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' lang='utf-8' xml:lang='utf-8'>
<head>
<title>How to get a random file name from a directory</title>
<meta http-equiv='Content-Type; charset=utf-8' />
<link rel='stylesheet' type='text/css' href='../../../lg.css' />
</head>
<body>
<a href="../../../"><img alt="Linux Gazette" src="../../../gx/2003/newlogo-blank-200-gold2.jpg" id="logo" /></a><img alt="Tux" src="../../../gx/tux_86x95_indexed.png" id="tux" /><p id="fun">...making Linux just a little more fun!</p><div class='content articlecontent'><a name="top"></a><h3>How to get a random file name from a directory</h3>
<p>
<b><p>
Suramya Tomar [security at suramya.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 00:40:30 +0530</b>
</p>

<p>
Hi Everyone,
</p>

<p>
I am working on a collage creation script in bash and am using find to 
get a list of all jpg files in a given directory. However find always 
returns the image names in the same order so the collage tends to have 
images from the same photo set i.e. at a given time it will have the 
most of the images from a particular subfolder.
</p>

<p>
What I want to do is get a list of random image file names from the 
system and then use it to create the collage, so that the collage looks 
more varied.
</p>

<p>
Here's what I have done so far to get a random file name:
</p>

<pre>
   awk "NR==$(($RANDOM % $(wc -l fi.txt| awk '{print $1}')))" fi.txt
</pre>

<p>
where fi.txt was created using
</p>

<pre>
   find . -iname "*.jpg" -true | sed 's/ /\\ /g' &gt;fi.txt
</pre>

<p>
Now, this way works but I have to create a temp file which I want to 
avoid. Is there some way of getting find to return results in a random 
order? I tried searching the web but didn't find any useful results.
</p>

<p>
I am attaching the current version of the Collage creation script with 
this email to give you an idea of how it works. This version is without 
randomization of the filenames.
</p>

<p>
Thanks in advance for the help.
</p>

<p>
- Suramya
</p>

<p>
PS: Please do give your feedback/suggestions on how the script can be 
improved in addition to a solution <img src="../gx/smile.png" alt=":)">
</p>


<p>
<pre class='code'>
#!/bin/bash
 
#########################################################################
# CreateCollage.sh Ver 0.5                                              #
# Script to Create a collage of images using the specified image set    #
# Created by Suramya Tomar (suramya@suramya.com)                        #
# Last updated 25th Nov 2008                                            #
#-----------------------------------------------------------------------#
# This program is free software; you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation; either version 2 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful, but   #
# WITHOUT ANY WARRANTY; without even the implied warranty of            #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      #
# General Public License for more details.                              #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program; if not, write to the                         #
# Free Software Foundation, Inc.,                                       #
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA                 #
#########################################################################
 
 
if [ $# -le 3 ]
then
 
 echo "
 $0 missing file operand.
 
 Usage: $0 &lt;Width&gt; &lt;Height&gt; &lt;Directory&gt; OutputImage
 The script creates a collage sized height x width out of the images in the directory specified. 
The resulting collage will be written as a jpg file into the Outputfile specified.
 
e.g. collageCreator.sh 640 480 images/ collage.jpg
 
will create a 640x480 image called collage.jpg and use the photos in the images directory to create a collage in it.
 
"
 exit 0
fi
 
# We assign the command line parameters to variables
 
width=$1
height=$2
SourceDirectory=$3
OutputImage=$4
 
# First we create a blank file for the collage
 
convert -size $1x$2 xc:black $OutputImage
 
# Then we search for all image files. I am just searching for jpg files as all my photos are jpg's
# and loop for each search result found and add it the collage
 
find $SourceDirectory -iname "*.jpg" -true | sed 's/ /\\ /g' |while read file
 
#awk "NR==$(($RANDOM % $(wc -l fi.txt| awk '{print $1}')))" fi.txt
 
# Now we start creating the collage
 
do
 
  # We have to seed the random number generator otherwise it tends to return the same set of results
  # We use the no of nanoseconds from the current date/time to seed it.
 
  RANDOM=`date '+%N'`
  x_location=`echo $(($RANDOM*$width/32767))`
  RANDOM=`date '+%N'`
  y_location=`echo $(($RANDOM*$height/32767))`
 
 
  echo $file
  # We insert the current image in the location selected by the random generator above in the output image
 
  composite -geometry 150x150+$x_location+$y_location "$file" $OutputImage $OutputImage
 
done
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Mon, 24 Nov 2008 19:48:50 +0000</b>
</p>

<p>
2008/11/24 Suramya Tomar &lt;security@suramya.com&gt;:
</p>

<pre>
&gt; Now, this way works but I have to create a temp file which I want to
&gt; avoid. Is there some way of getting find to return results in a random
&gt; order? I tried searching the web but didn't find any useful results.
</pre>

<p>
So something like:
</p>

<pre>
cd /some/where &amp;&amp; \
myfiles=(*.foo); num=${#myfiles[@]}; somecommand "${myfiles[RANDOM % num]}"
</pre>

<p>
Where "myfiles" will be an array from the glob, "num" is the size of
the array, and "${myfiles[RANDOM % num]}" selects a random element.
Change at will.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Will [will at willstuff.net]

</p>
</b><br />
<b>Mon, 24 Nov 2008 14:54:51 -0500</b>
</p>

<p>
Suramya Tomar wrote:
</p>

<pre>
&gt; Hi Everyone,
&gt;
&gt; I am working on a collage creation script in bash and am using find to 
&gt; get a list of all jpg files in a given directory. However find always 
&gt; returns the image names in the same order so the collage tends to have 
&gt; images from the same photo set i.e. at a given time it will have the 
&gt; most of the images from a particular subfolder.
&gt;
&gt; What I want to do is get a list of random image file names from the 
&gt; system and then use it to create the collage, so that the collage 
&gt; looks more varied.
&gt;
</pre>
There is program in the "coreutils" package that should help--shuf. It 
will take lines of input and display them in a randomized order:
</p>

<p>
<a href="http://www.gnu.org/software/coreutils/manual/html_node/shuf-invocation.html">http://www.gnu.org/software/coreutils/manual/html_node/shuf-invocation.html</a>
</p>

<p>
You could pipe the output of find to it, like this:
</p>

<pre>
find . -iname "*.jpg" -print | shuf
</pre>

<p>
Here's a simple test I ran with filenames "file1.jpg" through "file5.jpg"
</p>

<p>
<pre class='code'>
$ find . -iname "*.jpg" -print | shuf
./file3.jpg
./file2.jpg
./file4.jpg
./file5.jpg
./file1.jpg
$ find . -iname "*.jpg" -print | shuf
./file4.jpg
./file2.jpg
./file3.jpg
./file1.jpg
./file5.jpg
$ find . -iname "*.jpg" -print | shuf
./file4.jpg
./file1.jpg
./file3.jpg
./file5.jpg
./file2.jpg
</pre>

<p>
Hope that helps.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Mon, 24 Nov 2008 19:59:39 +0000</b>
</p>

<p>
2008/11/24 Will &lt;will@willstuff.net&gt;:
</p>

<pre>
&gt; There is program in the "coreutils" package that should help--shuf. It
&gt; will take lines of input and display them in a randomized order:
</pre>

<p>
AFAIK this is non-portable on things like BSD.  Besides, if you're
wanting to be coreutil specific, sort learnt the -R flag for
randomising a sort as over version 6.something.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Jim Jackson [jj at franjam.org.uk]

</p>
</b><br />
<b>Mon, 24 Nov 2008 21:23:05 +0000 (GMT)</b>
</p>

<p>
I remember something similar I squirrelled away from the TAG archives.
As Ben hasn't chipped in yet, let me on his behalf give you a perl one 
liner that could be utilised thus...
</p>

<p>
<pre class='code'>
  cd directory
  find .  -maxdepth 1 -type f |\
   perl -we'rand($.) &lt; 1 &amp;&amp; ($pick = $_) while &lt;&gt;; print $pick'
</pre>

<p>
Here's the TAG email...
</p>


<pre>
Date: Wed, 8 Aug 2007 15:04:10 -0400
From: Ben Okopnik &lt;ben@linuxgazette.net&gt;
To: The Answer Gang &lt;tag@lists.linuxgazette.net&gt;
</pre>
There's a nifty little "random picker" algorithm that I got from Randal
Schwartz a while ago - I don't think he invented it, but it works really
well for choosing a random line from a file:
</p>

<p>
<pre class='code'>
perl -we'rand($.) &lt; 1 &amp;&amp; ($pick = $_) while &lt;&gt;; print $pick' file
</pre>

<pre>
1. line 1: test 'rand(1)&lt;1' (100% chance: 'rand' always returns &lt;1)
2. line 2: test 'rand(2)&lt;1' (1/2 chance that line 2 will replace $pick)
3. line 3: test 'rand(3)&lt;1' (1/3 chance that line 3 will replace $pick)
...
</pre>

<p>
Pretty cool stuff. The important thing is the chance of replacement on
every line; it ends up spreading out very fairly.
</p>


<pre>
&gt; Err but line 300 has a chance of only 1/300 of replacing $pick. Still
&gt; don't quite get
&gt; it, I'll eventually......
</pre>

<p>
Yes - but the chances for <em>any</em> line of both being picked and NOT being
replaced are equal. That's the trick to it.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Kapil Hari Paranjape [kapil at imsc.res.in]

</p>
</b><br />
<b>Tue, 25 Nov 2008 06:15:38 +0530</b>
</p>

<p>
Hello,
</p>

<p>
On Mon, 24 Nov 2008, Jim Jackson wrote:
</p>

<pre>
&gt; ```
&gt;   cd directory
&gt;   find .  -maxdepth 1 -type f |\
&gt;    perl -we'rand($.) &lt; 1 &amp;&amp; ($pick = $_) while &lt;&gt;; print $pick'
&gt; '''
</pre>

<p>
While this works fine in principle (as does "shuf"), the disadvantage
of both is that they are permuting a (possibly large) list in order
to <em>select</em> a random element.
</p>

<p>
Ideally, to do the latter one would:
</p>

<pre>
 1. get the number of elements in the list of files
    (possibly by doing a "stat" on the directory inode)
 2. pick a random number which is between 0 and that number
 3. run an "ls" and pick that-eth element from the output
</pre>

<p>
For really large file lists I believe this method (which is more or
less what Suramya did with his awk program) would be faster.
</p>

<p>
Kapil.
--
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Mon, 24 Nov 2008 21:42:13 -0500</b>
</p>

<p>
On Mon, Nov 24, 2008 at 09:23:05PM +0000, Jim Jackson wrote:
</p>

<pre>
&gt; 
&gt; I remember something similar I squirrelled away from the TAG archives.
&gt; As Ben hasn't chipped in yet, let me on his behalf give you a perl one 
&gt; liner that could be utilised thus...
&gt; 
&gt; ```
&gt;   cd directory
&gt;   find .  -maxdepth 1 -type f |\
&gt;    perl -we'rand($.) &lt; 1 &amp;&amp; ($pick = $_) while &lt;&gt;; print $pick'
&gt; '''
</pre>

<p>
I was just about to repost that one. <img src="../gx/smile.png" alt=":)"> Well done, Jim!
</p>

<p>
The same thing can also be done using Perl's looping option:
</p>

<pre>
find /my/dir -name '*jpg'|perl -wne'rand($.)&lt;1&amp;&amp;($x=$_);END{print $x}'
</pre>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Mon, 24 Nov 2008 22:05:24 -0500</b>
</p>

<p>
On Tue, Nov 25, 2008 at 06:15:38AM +0530, Kapil Hari Paranjape wrote:
</p>

<pre>
&gt; 
&gt; While this works fine in principle (as does "shuf"), the disadvantage
&gt; of both is that they are permuting a (possibly large) list in order
&gt; to <em>select</em> a random element.
&gt; 
&gt; Ideally, to do the latter one would:
&gt;  1. get the number of elements in the list of files
&gt;     (possibly by doing a "stat" on the directory inode)
&gt;  2. pick a random number which is between 0 and that number
&gt;  3. run an "ls" and pick that-eth element from the output
&gt; 
&gt; For really large file lists I believe this method (which is more or
&gt; less what Suramya did with his awk program) would be faster.
</pre>

<p>
You have a point. I've done something like that in the past, in a shell
script; in fact, now that I've looked for it and found it, it does
almost exactly what Suramya is doing (except I was searching for XPMs,
and using 'locate'.) Here's a slightly modified version:
</p>

<pre>
a=(`find /my/dir -name '*jpg'`); echo ${a[$(($RANDOM*${#a[*]}/32768))]}
</pre>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Deividson Okopnik [deivid.okop at gmail.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 09:26:32 -0300</b>
</p>

<pre>
&gt; You have a point. I've done something like that in the past, in a shell
&gt; script; in fact, now that I've looked for it and found it, it does
&gt; almost exactly what Suramya is doing (except I was searching for XPMs,
&gt; and using 'locate'.) Here's a slightly modified version:
&gt;
&gt; ``
&gt; a=(`find /my/dir -name '*jpg'`); echo ${a[$(($RANDOM*${#a[*]}/32768))]}
&gt; ''
</pre>

<p>
That would be fine to select one random jpg, but wouldnt it create
duplicates if you run it like he is? For what he is using I think shuf
would be the best, unless displaying the same photo several times is
not a problem.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Suramya Tomar [security at suramya.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 19:57:23 +0530</b>
</p>

<p>
Hey Will,
</p>


<pre>
&gt; There is program in the "coreutils" package that should help--shuf. It 
&gt; will take lines of input and display them in a randomized order:
</pre>

<p>
Thanks. This is exactly what I was looking for. <img src="../gx/smile.png" alt=":)">
</p>


<pre>
&gt; Hope that helps.
</pre>

<p>
It defenitly did help.
</p>

<p>
Thanks,
</p>

<p>
Suramya
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Suramya Tomar [security at suramya.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 20:04:04 +0530</b>
</p>

<p>
Hey,
</p>


<pre>
&gt; That would be fine to select one random jpg, but wouldnt it create
&gt; duplicates if you run it like he is? For what he is using I think shuf
&gt; would be the best, unless displaying the same photo several times is
&gt; not a problem.
</pre>

<p>
It does return duplicates but I will have to run it on a large file set 
to see how many repetitions are there. A few duplicates won't be that 
big a deal but if it starts returning the same fileset over and over 
then the collage would look a bit funny.
</p>

<p>
I will run a test once I get home to see how many repetitions are there.
</p>

<p>
Another concern I have is about memory usage and runtime. I would prefer 
to use an option that is faster. I will try to time both and will post 
my findings, but I think the one using 'shuf' would be faster.
</p>

<p>
Thanks,
</p>

<p>
Suramya
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Tue, 25 Nov 2008 09:50:59 -0500</b>
</p>

<p>
On Tue, Nov 25, 2008 at 09:26:32AM -0300, Deividson Okopnik wrote:
</p>

<pre>
&gt; &gt; You have a point. I've done something like that in the past, in a shell
&gt; &gt; script; in fact, now that I've looked for it and found it, it does
&gt; &gt; almost exactly what Suramya is doing (except I was searching for XPMs,
&gt; &gt; and using 'locate'.) Here's a slightly modified version:
&gt; &gt;
&gt; &gt; ``
&gt; &gt; a=(`find /my/dir -name '*jpg'`); echo ${a[$(($RANDOM*${#a[*]}/32768))]}
&gt; &gt; ''
&gt; 
&gt; That would be fine to select one random jpg, but wouldnt it create
&gt; duplicates if you run it like he is? For what he is using I think shuf
&gt; would be the best, unless displaying the same photo several times is
&gt; not a problem.
</pre>

<p>
Ah - I (and persumably Kapil also) had lost track of the fact that
Suramya wants all the files sorted in random order rather than just one
random file. Yes, at that point, 'shuf' is a good solution - or, if you
don't have 'shuf', there's always Perl.
</p>

<pre>
#!/usr/bin/perl -wl
# Created by Ben Okopnik on Tue Nov 25 09:44:15 EST 2008
use strict;
use File::Find;
use List::Util 'shuffle';
 
my @list;
find(sub {push @list, $_ if /jpg$/}, "/home/ben/Pics");
print for shuffle(@list);
</pre>

<p>
Both File::Find and List::Util are Perl core modules, meaning that if
you have Perl, you already have these installed. "List::Util::shuffle"
does a Fisher-Yates shuffle, so the list is quite nicely randomized.
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Tue, 25 Nov 2008 09:56:33 -0500</b>
</p>

<p>
On Tue, Nov 25, 2008 at 09:50:59AM -0500, Benjamin Okopnik wrote:
</p>

<pre>
&gt; 
&gt; my @list;
&gt; find(sub {push @list, $_ if /jpg$/}, "/home/ben/Pics");
</pre>

<p>
Actually, that should be
</p>

<pre>
find(sub {push @list, $File::Find::name if /jpg$/}, "/my/pic/dir");
</pre>

<p>
- assuming you want the full paths (and not just the filenames) to be
printed.
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Michael Makuch [mike8 at makuch.org]

</p>
</b><br />
<b>Tue, 25 Nov 2008 09:29:03 -0600</b>
</p>

<p>
Deividson Okopnik wrote:
</p>

<pre>
&gt;&gt; You have a point. I've done something like that in the past, in a shell
&gt;&gt; a=(`find /my/dir -name '*jpg'`); echo ${a[$(($RANDOM*${#a[*]}/32768))]}
&gt;&gt;     
&gt;
&gt; That would be fine to select one random jpg, but wouldnt it create
&gt; duplicates if you run it like he is? For what he is using I think shuf
&gt;
&gt;   
</pre>
What's wrong with;
</p>

<pre>
    a=`find /path2pics | sort -R`
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Thomas Adam [thomas.adam22 at gmail.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 15:59:59 +0000</b>
</p>

<p>
2008/11/25 Michael Makuch &lt;mike8 at makuch dot org&gt;:
</p>

<pre>
&gt; What's wrong with;
&gt;
&gt;     a=`find /path2pics | sort -R`
</pre>

<p>
As I mentioned in my post regarding its use -- it's Linux specific.
</p>

<p>
-- Thomas Adam
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Kapil Hari Paranjape [kapil at imsc.res.in]

</p>
</b><br />
<b>Tue, 25 Nov 2008 22:05:03 +0530</b>
</p>

<p>
On Tue, 25 Nov 2008, Ben Okopnik wrote:
</p>

<pre>
&gt; Ah - I (and persumably Kapil also) had lost track of the fact that
&gt; Suramya wants all the files sorted in random order rather than just one
&gt; random file.
</pre>

<p>
The subject of his mail says he wants to pick a file at random from a list of
files!
</p>

<p>
On <em>reading</em> his mail I realised that he said he wanted to get the
files in a different (random) order.
</p>

<p>
An interesting side light is the "birthday paradox" which says that
if you pick by "my method" (pick a random number and pick that-eth
picture), and do this enough times, it is like that a few pictures
will be picked more than once.
</p>

<p>
Kapil.
--
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Tue, 25 Nov 2008 16:51:20 -0500</b>
</p>

<p>
[ Michael - you're probably unaware of this, but you sent your message in
HTML format. This doubled the size of your message without any benefit
in return, and will create extra work for our Mailbag editor.
</p>

<p>
Please change your mailer's settings to stop it from doing this. For
more info, please see &lt;<a href="http://expita.com/nomime.html&gt;">http://expita.com/nomime.html&gt;</a>. ]
</p>

<p>
On Tue, Nov 25, 2008 at 09:29:03AM -0600, Michael Makuch wrote:
</p>

<pre>
&gt;    Deividson Okopnik wrote:
&gt; 
&gt;  You have a point. I've done something like that in the past, in a shell
&gt;  a=(`find /my/dir -name '*jpg'`); echo ${a[$(($RANDOM*${#a[*]}/32768))]}
&gt;     
&gt; 
&gt;  That would be fine to select one random jpg, but wouldnt it create
&gt;  duplicates if you run it like he is? For what he is using I think shuf
&gt; 
&gt;    What's wrong with;
&gt; 
&gt;        a=`find /path2pics | sort -R`
</pre>

<p>
Lack of portability. Bash and Perl are found on most versions of Unix
these days, but 'sort' that supports '-R' is still a rare bird.
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Tue, 25 Nov 2008 17:07:27 -0500</b>
</p>

<p>
On Tue, Nov 25, 2008 at 10:05:03PM +0530, Kapil Hari Paranjape wrote:
</p>

<pre>
&gt; On Tue, 25 Nov 2008, Ben Okopnik wrote:
&gt; &gt; Ah - I (and persumably Kapil also) had lost track of the fact that
&gt; &gt; Suramya wants all the files sorted in random order rather than just one
&gt; &gt; random file.
&gt; 
&gt; The subject of his mail says he wants to pick a file at random from a list of
&gt; files!
</pre>

<p>
Oh - you actually read and <em>believe</em> those things? <img src="../gx/smile.png" alt=":)">
 
</p>

<pre>
&gt; On <em>reading</em> his mail I realised that he said he wanted to get the
&gt; files in a different (random) order.
&gt; 
&gt; An interesting side light is the "birthday paradox" which says that
&gt; if you pick by "my method" (pick a random number and pick that-eth
&gt; picture), and do this enough times, it is like that a few pictures
&gt; will be picked more than once.
</pre>

<p>
I hadn't thought about it, but you're right, of course.
</p>

<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Deividson Okopnik [deivid.okop at gmail.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 21:34:06 -0300</b>
</p>

<pre>
&gt;&gt; An interesting side light is the "birthday paradox" which says that
&gt;&gt; if you pick by "my method" (pick a random number and pick that-eth
&gt;&gt; picture), and do this enough times, it is like that a few pictures
&gt;&gt; will be picked more than once.
</pre>

<p>
Problem number two is: you can never know when you got all the files.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Samuel Bisbee [sbisbee at computervip.com]

</p>
</b><br />
<b>Tue, 25 Nov 2008 20:24:13 -0500</b>
</p>

<p>
Deividson Okopnik wrote:
</p>

<pre>
&gt;&gt;&gt; An interesting side light is the "birthday paradox" which says that
&gt;&gt;&gt; if you pick by "my method" (pick a random number and pick that-eth
&gt;&gt;&gt; picture), and do this enough times, it is like that a few pictures
&gt;&gt;&gt; will be picked more than once.
&gt;
&gt; Problem number two is: you can never know when you got all the files.
</pre>

<p>
Eh, not sure I'm with you there Deividson. This would really depend on 
your implementation: whether you hold the whole set in memory and 
select/remove items from the set, or whether you select items from the 
set and leave them in there (silly). Even sillier would be to run `ls` 
every time.
</p>

<p>
The first (according to me, "not silly") way is:
</p>

<pre>
1. Store the file paths in memory (array or language's type of choice)
2. Shuffle the array
3. Iterate over the array, throwing images into the collage.
</pre>

<p>
However, this can be made better: depending on the shuffle method used, 
we might be iterating over all the elements in the set twice. No good, 
so here's a better solution in pseudo code (assumes the 
set/array/whatever is 0-indexed):
</p>

<pre>
array set = paths from ls
while(set.length &gt; 0)
{
   int i = RANDOM % set.length
   putInCollage(set[i])
   switch(i)
   {
     0: set = array(set[1 .. set.length-1])
     set.length-1: set = array(set[0 .. set.length-2])
     *: set = array(set[0 .. i-1] + set[i+1 .. set.length-1])
   }
}
</pre>

<p>
Please excuse the roughness of the "code", but I just got home from 
work. <img src="../gx/smile.png" alt=":-)">
</p>

<p>
Of course, I could have just misunderstood you, in which case I hope 
someone finds this useful for other reasons.
</p>

<p>
Peace,
</p>

<pre>-- 
Sam Bisbee
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Will [will at willstuff.net]

</p>
</b><br />
<b>Wed, 26 Nov 2008 09:53:41 -0500</b>
</p>

<p>
Thomas Adam wrote:
</p>

<pre>
&gt; 2008/11/24 Will &lt;will@willstuff.net&gt;:
&gt;   
&gt;&gt; There is program in the "coreutils" package that should help--shuf. It
&gt;&gt; will take lines of input and display them in a randomized order:
&gt;&gt;     
&gt;
&gt; AFAIK this is non-portable on things like BSD.  Besides, if you're
&gt; wanting to be coreutil specific, sort learnt the -R flag for
&gt; randomising a sort as over version 6.something.
</pre>

<p>
AFAIK this is a Linux help group. So it's completely portable across the 
systems concerned here (every distro will have coreutils). The simplest 
answer is usually best.
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Michael Makuch [linuxgazette at makuch.org]

</p>
</b><br />
<b>Wed, 26 Nov 2008 09:18:57 -0600</b>
</p>

<p>
Will wrote:
</p>

<pre>
&gt; Thomas Adam wrote:
&gt;   
&gt;&gt; 2008/11/24 Will &lt;will@willstuff.net&gt;:
&gt;&gt;   
&gt;&gt;     
&gt;&gt;&gt; There is program in the "coreutils" package that should help--shuf. It
&gt;&gt;&gt; will take lines of input and display them in a randomized order:
&gt;&gt;&gt;     
&gt;&gt;&gt;       
&gt;&gt; AFAIK this is non-portable on things like BSD.  Besides, if you're
&gt;&gt; wanting to be coreutil specific, sort learnt the -R flag for
&gt;&gt; randomising a sort as over version 6.something.
&gt;&gt;
&gt;&gt;   
&gt;&gt;     
&gt; AFAIK this is a Linux help group. So it's completely portable across the 
&gt; systems concerned here (every distro will have coreutils). The simplest 
&gt; answer is usually best.
&gt;   
</pre>

<p>
I was wondering about that. Interesting that the linux only solution was 
so quickly dismissed.
</p>

<p>
Isn't it more instructive to discuss all potential good solutions? Or do
the dominant opinions here feel that one should always strive for 100%
portability? Even at the expense of more development time? Where do you
draw the line?
</p>

<p>
I am all in favor of promoting portability, but I also code in the real 
world.
</p>

<p>
Mike
</p>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Samuel Bisbee-vonKaufmann [sbisbee at computervip.com]

</p>
</b><br />
<b>Wed, 26 Nov 2008 15:43:51 +0000</b>
</p>

<pre>
&gt;Will wrote:
&gt;&gt; Thomas Adam wrote:
&gt;&gt;   
&gt;&gt;&gt; 2008/11/24 Will &lt;will@willstuff.net&gt;:
&gt;&gt;&gt;   
&gt;&gt;&gt;     
&gt;&gt;&gt;&gt; There is program in the "coreutils" package that should help--shuf. It
&gt;&gt;&gt;&gt; will take lines of input and display them in a randomized order:
&gt;&gt;&gt;&gt;     
&gt;&gt;&gt;&gt;       
&gt;&gt;&gt; AFAIK this is non-portable on things like BSD.  Besides, if you're
&gt;&gt;&gt; wanting to be coreutil specific, sort learnt the -R flag for
&gt;&gt;&gt; randomising a sort as over version 6.something.
&gt;&gt;&gt;
&gt;&gt;&gt;   
&gt;&gt;&gt;     
&gt;&gt; AFAIK this is a Linux help group. So it's completely portable across the 
&gt;&gt; systems concerned here (every distro will have coreutils). The simplest 
&gt;&gt; answer is usually best.
&gt;&gt;   
&gt;
&gt;I was wondering about that. Interesting that the linux only solution was 
&gt;so quickly dismissed.
&gt;
&gt;Isn't it more instructive to discuss all potential good solutions? 
</pre>

<p>
That's exactly what people are doing. You will find on this list that
people are constantly pushing and challenging, together trying to find
the best solution. Usually in a friendly manner. <img src="../gx/smile.png" alt=":-)">
</p>


<pre>
&gt;Or do 
&gt;the dominant opinions here
&gt;feel that one should always strive for 100% portability? Even at the 
&gt;expense of more development
&gt;time? Where do you draw the line?
&gt;
</pre>

<p>
I don't think anyone is suggesting 100% portability (don't forget
MINIX!). However, this was a shell scripting question and there's often
little reason to not have shell scripts be portable. It's really one of
those "why use /bin/bash when /bin/sh would run all that syntax?"
questions.
</p>

<p>
Also, I would argue that "development time" really wasn't that much more.
</p>


<pre>
&gt;I am all in favor of promoting portability, but I also code in the real 
&gt;world.
&gt;
</pre>

<p>
I always love these lines, "I code for big business, so that makes my
experience with programming more realistic than yours." As someone who
has coded for all sizes of companies/groups/fun, I have found that it's
all the same. The only difference(s) are logistical/political, which
manifest differently depending on the environment. However, that has no
bearing on what the best solution to the problem is. Just because you
have to meet a deadline and therefore go with an exponential time
solution doesn't make that solution faster than a linear time solution.
</p>

<pre>-- 
Sam Bisbee
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Wed, 26 Nov 2008 20:24:10 -0500</b>
</p>

<p>
On Wed, Nov 26, 2008 at 09:53:41AM -0500, Will wrote:
</p>

<pre>
&gt; Thomas Adam wrote:
&gt; &gt; 2008/11/24 Will &lt;will@willstuff.net&gt;:
&gt; &gt;   
&gt; &gt;&gt; There is program in the "coreutils" package that should help--shuf. It
&gt; &gt;&gt; will take lines of input and display them in a randomized order:
&gt; &gt;&gt;     
&gt; &gt;
&gt; &gt; AFAIK this is non-portable on things like BSD.  Besides, if you're
&gt; &gt; wanting to be coreutil specific, sort learnt the -R flag for
&gt; &gt; randomising a sort as over version 6.something.
&gt; &gt;
&gt; &gt;   
&gt; AFAIK this is a Linux help group.
</pre>

<p>
Actually, we often focus on broader issues whenever possible - as in
this case. There's little or nothing restricting solutions to a problem
like this to being Linux-only, so why not make it as usable as possible?
As I've often noted before, the smartest thing to do in this group (as
in many other learning environments) is to take constructive criticism
with gratitude rather than, say, bristling at it.
</p>


<pre>
&gt; So it's completely portable across the 
&gt; systems concerned here (every distro will have coreutils).
</pre>

<p>
Well, no. Tom's RootBoot doesn't, for example; most of the utilities in
it, including "sort", are built with busybox - and I'm pretty sure that
it doesn't support the "-R" option. There is a number of other Linuxen
listed in
'<a href="http://en.wikipedia.org/wiki/List_of_Linux_distributions#Others">http://en.wikipedia.org/wiki/List_of_Linux_distributions#Others</a>', many
of which would be an even-money bet for that, too.
</p>


<pre>
&gt; The simplest 
&gt; answer is usually best.
</pre>

<p>
That is certainly a common and trivially-cited platitude - one which is
not in the least helpful. What is "simplest"? Doesn't it depend on the
problem? Perhaps chopping someone's head off when they need brain
surgery would be <strong>simplest</strong>, but it would not necessarily be best.
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Wed, 26 Nov 2008 20:31:23 -0500</b>
</p>

<p>
On Wed, Nov 26, 2008 at 09:18:57AM -0600, Michael Makuch wrote:
</p>

<pre>
&gt; Will wrote:
&gt; &gt;     
&gt; &gt; AFAIK this is a Linux help group. So it's completely portable across the 
&gt; &gt; systems concerned here (every distro will have coreutils). The simplest 
&gt; &gt; answer is usually best.
&gt; 
&gt; I was wondering about that. Interesting that the linux only solution was 
&gt; so quickly dismissed.
</pre>

<p>
It wasn't "dismissed", as I recall; rather, it was noted that it wasn't
portable. The decision about dismissing it or not is left up to the
person who needs to solve the problem - which is squarely where that
responsibility should fall. Providing more, better, and broader answers
is what we do here so as to give more options to those who need to make
those decisions.
 
</p>

<pre>
&gt; Isn't it more instructive to discuss all potential good solutions? Or do 
&gt; the dominant opinions here
&gt; feel that one should always strive for 100% portability?
</pre>

<p>
Yes to both.
</p>


<pre>
&gt; Even at the 
&gt; expense of more development
&gt; time? Where do you draw the line?
</pre>

<p>
How much time do you have? Feel free to post however many appropriate
solutions you see consonant with the time you feel you have to spend on
it; others will, theoretically, critique your solutions (again, based on
the time that they have) - and out of the discussion comes the best
approach that we have. That's what people do in discussion groups.
 
</p>

<pre>
&gt; I am all in favor of promoting portability, but I also code in the real 
&gt; world.
</pre>

<p>
I'd be <strong>fascinated</strong> to know what alternatives you believe exist to
coding in the real world. Do you believe that some people code in, say,
a world that's 90 degrees to this one? Or perhaps in Emerald City? I'd
like to see a job app for one of those - or better yet, a Trip-Tik. <img src="../gx/smile.png" alt=":)">
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Wed, 26 Nov 2008 20:34:27 -0500</b>
</p>

<p>
On Wed, Nov 26, 2008 at 03:43:51PM +0000, Samuel Bisbee-vonKaufmann wrote:
</p>

<pre>
&gt; 
&gt; I don't think anyone is suggesting 100% portability (don't forget
&gt; MINIX!). However, this was a shell scripting question and there's
&gt; often little reason to not have shell scripts be portable. It's really
&gt; one of those "why use /bin/bash when /bin/sh would run all that
&gt; syntax?" questions.
&gt; 
&gt; Also, I would argue that "development time" really wasn't that much more.
</pre>

<p>
Often, it comes down to simply using "printf" instead of "echo" and not
using {Bash,KSH,C,etc.}-isms.
 
</p>

<pre>
&gt; &gt;I am all in favor of promoting portability, but I also code in the real 
&gt; &gt;world.
&gt; &gt;
&gt; 
&gt; I always love these lines, "I code for big business, so that makes my
&gt; experience with programming more realistic than yours." As someone who
&gt; has coded for all sizes of companies/groups/fun, I have found that
&gt; it's all the same.
</pre>

<p>
Sam, that implies that your professional ethics are more important than
the environment in which you work. How dare you, sir!... I knew I liked
you for a reason. <img src="../gx/smile.png" alt=":)">
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Rick Moen [rick at linuxmafia.com]

</p>
</b><br />
<b>Wed, 26 Nov 2008 18:56:07 -0800</b>
</p>

<p>
Quoting Ben Okopnik (ben@linuxgazette.net):
</p>


<pre>
&gt; Actually, we often focus on broader issues whenever possible - as in
&gt; this case. There's little or nothing restricting solutions to a problem
&gt; like this to being Linux-only, so why not make it as usable as possible?
</pre>

<p>
(/me dons his Rhetorical Questions Answered Cheap hat.)
</p>

<p>
I have noticed over the years that bashisms and Linuxisms tend to
increase readability and conciseness -- at least a bit.  The examples I
can most quickly recall are
<pre>
  export variable=value 
</pre>
as opposed to 
<pre>
  set variable=value
  export variable
</pre>
and
<pre>
  ln -sf foo bar
</pre>
as opposed to 
<pre>
  if [-f bar]; then unlink bar; fi
  ln -s foo bar
</pre>
Point is, portability can exact a cost.  (If you want your Bourne
scripts to work on systems that don't support symlinks at all, you'll
need to cruft up those "ln -s" commands with a bunch more logic, nei?)
</p>

<p>
Extensions are crunchy and delicious!  ;-&gt;
</p>

<pre>-- 
Cheers,                "I'm sorry Dan, what's right isn't always popular, 
Rick Moen              and what's popular isn't always right."
rick@linuxmafia.com                     -- George R. Moscone, Nov. 27, 1978
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p><p>
<b><p>
Ben Okopnik [ben at linuxgazette.net]

</p>
</b><br />
<b>Wed, 26 Nov 2008 22:37:34 -0500</b>
</p>

<p>
On Wed, Nov 26, 2008 at 06:56:07PM -0800, Rick Moen wrote:
</p>

<pre>
&gt; 
&gt; Point is, portability can exact a cost.  (If you want your Bourne
&gt; scripts to work on systems that don't support symlinks at all, you'll
&gt; need to cruft up those "ln -s" commands with a bunch more logic, nei?)
</pre>

<p>
In Perl, at least, it's simple:
</p>

<pre>
# What do you mean, "Flash Gordon has escaped"???
die "Die, scum-sucking demon from Hell!!!\n" if eval { symlink('',''); 1 }
 
# Rest of script follows
</pre>

<p>
In Bash, it's a little more crunchy - although there's $OSTYPE to lead
you to water.
</p>


<pre>-- 
* Ben Okopnik * Editor-in-Chief, Linux Gazette * <a href="http://LinuxGazette.NET">http://LinuxGazette.NET</a> *
</pre>

<p>

</p>
<br /><a href="#top">Top</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="../../lg_mail.html#mb-how_to_get_a_random_file_name_from_a_directory">Back</a><hr width="50%" align="left" /><p><br /></p></div>
</body>
</html>
