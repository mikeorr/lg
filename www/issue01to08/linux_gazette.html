<HTML>

<HEAD>
<TITLE>Linux Gazette July, 1995</TITLE>
</HEAD>

<BODY>

<H1><IMG ALIGN=MIDDLE SRC="./gx/homeboy_icon.gif">Linux Gazette July, 1995</H1>
<H3>A Publication of the Linux HomeBoy WebPage Series</H3>

<H5>Copyright (c) 1995 John M. Fisk <I>fiskjm@ctrvax.vanderbilt.edu</I><BR><BR>
The LINUX GAZETTE is now a member of the LINUX DOCUMENTATION PROJECT.<BR>
For information regarding copying and distribution of this material see the
<A HREF="./copying.html">COPYING</A> document.<BR>
Linux Home Boy Pages logo created using <EM>David Koblas'</EM> excellent
program XPAINT 2.1.1 </H5>

<HR>

<H2> Topics in this <EM>premier</EM> issue include:</H2>
<UL>
<LI><A HREF="#whatis">So what <I>is</I> the Linux Gazette...</A>
<LI><A HREF="#offwego">And off we go...</A>
<LI><A HREF="#motd">So what <I>is</I> this MOTD thingy...</A>
<LI><A HREF="#alias">Aliasing for fun and efficiency</A>
<LI><A HREF="#functions">Adding some functions for even more time savings</A>
<LI><A HREF="#au">Playing .AU at boot up</A>
<LI><A HREF="#mounting">Mounting your cdrom and floppies the <I>easy</I> way</A>
<LI><A HREF="#configs">Managing your wandering system configuration files</A>
<LI><A HREF="#ext2tool">Accessing Linux from DOS!?</A>
<LI><A HREF="#kernel">Rolling your own kernel... it ain't that tough</A>
<LI><A HREF="#testdrive">Test driving you new kernel the safe way</A>
<LI><A HREF="#thatsit">Well, that's it</A>
</UL>

<BR>  
<HR>

<A NAME="whatis"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">So what <I>is</I> the Linux Gazette... </H2></A>

<P>Primarily writings, ramblings, and other stuff...

<P>About a year ago, after getting my first glimpse of the internet via a dial-up
2400 baud VAX account (<EM>ouch!...</EM>), I started reading about a freely available
UN*X-like operating system that would let you run a unix operating system on an i386
or better PC.  Sounded good to me...

<P>So... after spending <EM>days</EM> tying up the dial-up line into the wee hours
of the morning, AND after spending 45 bucks in floppies, I finally managed to get
a copy of <B>Slackware 2.0.0</B>.  I spent an entire afternoon thereafter shoveling
disks in and out of my PC and watching dialog after dialog describe what was happening.
Eventually, I managed to get it all loaded up, rebooted, and <STRONG>presto!</STRONG>...

<P><B>LINUX!</B>

<P>I got hooked!  This thing was awesome, huge, and bewildering.  At times it was
so frustrating that I was sure it was either a 120MB virus in disguise... or possessed.
Eventually, I started making some headway and things worked!  Now, I was really
hooked.  What had happened was that by reading everything I could find --
<UL>
<LI>comp.os.linux.*
<LI>The Linux User's Guide (from the Linux Documentation Project (LDP))
<LI>Linux Installation and Getting Started (LDP)
<LI>the Network Administrator's Guide (LDP)
<LI>the System Administrator's Guide (LDP)
<LI>a <B>boatload</B> of FAQ's and HOWTO's
<LI><I>Running Linux</I> by Matt Welsh and Lar Kaufman (published by O'Reilly)
<LI><I>Linux - Unleashing the Workstation in Your PC</I> by Stephan Strobel and
Thomas Uhl (published by Springer-Verlag)
<LI><I>X Window System Uer's Guide</I> by Valerie Querica and Tim O'Reilly (published by
O'Reilly)
<LI>and several general books on UNIX such as <I>A Student's Guide to UNIX</I> by
Harley Hahn, <I>Essential System Administration</I> by Aeleen Frisch, and
<I>Shell Programming</I> by Kamran Husain.
</UL>
and then playing around with things until they either worked or broke (fortunately,
mostly the former :-), Linux finally <EM>began to make sense to me.</EM>

<P>If you're in the same boat... keep paddling!  The result is definitely worth it!
Running Linux means having to do your homework.  It's a matter of reading and learning
until things make sense.  There are LOTS of folks out there who are more than willing
to help and have invested a LOT of time into writing the documentation that makes
Linux knowable.  

<P>Great software without the knowledge to run it is pretty useless.

<P>Sermon over.  What I've tried to do with the <B>Linux Gazette</B> is pass along
some of the ideas that I've tried, liked, and have worked for me.  Just one caveat:

<P><STRONG>This ain't technical wizardry and it won't advance you to gurudom...</STRONG>

<P>Hopefully, what it will do is make running Linux a bit more fun, enjoyable, or
easier.  This is a compilation of ideas I've shamelessly plagerized from so many
sources that, quite frankly, I'm not sure where some of them came from, let alone
being able to give due credit to the originator.  And so... <B>to the great nameless,
faceless, unknown but all-knowing Linux gurus</B> (ooh, kinda spooky, eh?)...

<P>Thanks.
<BR><BR>

<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>
<HR>

<A NAME="offwego"><H2><IMG SRC="../gx/text.gif">And off we go...</H2></A>

<P>What I'll try to do is make this as pleasant, or at least as painless, as possible.
It's admittedly a bit loose and rambly and probably best purused when you've got a
bit of time to browse...

<P>eh?... what?!  Your student account at rigid.frigid.toxic-megahosers.edu times
you out at 2 minutes of inactivity?!  Hosers.

<P>Try this.  If you're running a PPP account set up a small shell script:

<PRE>
	#!/bin/sh
	#program:	hose-em
	#purpose:	keeps a dial-up line from timing out while you're
	#		reading Web stuff or doing your laundry (OK... let's be
	#		responsible)
	#
	# We'll use the gateway server as your host.
	HOST=000.00.00.000	# the dotted-quad address of your gateway which
				# you can get by typing "ifconfig"
	SLEEP=8m		# how long we'll wait between pings

	###############################################################################
	#
	# Set up a while loop that pings the host as long as the PID file exists.
	# But first, make sure that the connection is still up.
	#
	if [ -e "/var/run/ppp0.pid" ]; then
		echo "
		* * *    PPP-UP is running   * * * 
	     "
	else
		echo "
		* * * 	 PPP0 interface is not up!  * * * 
	     "
		exit 1
	fi

	while [ -e "/var/run/ppp0.pid" ]	# Now, set up the while loop.
	do					# As long as the PID file exists
		ping -c 1 $HOST > /dev/null	# we'll ping the host once every 8 min.
		sleep $SLEEP
	done
	exit 0	
</PRE>

you'll notice we use the <CODE>ping -c 1</CODE> designation -- that keeps ping from
endlessly pinging.  Set the variable <CODE>SLEEP=</CODE> to whatever interval you
need.  And that's it!  Don't forget to <CODE>chmod 711 hose-em</CODE> when you're
done.  

<P>Now, you can browse in peace.  When you terminate the link, the while-loop ends
and ping goes back to sleep.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>
<HR>

<A NAME="motd"><H2><IMG SRC="../gx/text.gif">So what is this MOTD thingy and <I>who keeps eating my issue...!</I></H2></A>

<P>Ever notice that when you log into Linux you get the same ol'
<PRE>
Welcome to Linux 1.x.x.
Login:

Linux 1.x.x. (POSIX)
</PRE>

...and you finally discover <B>/etc/issue</B> and <B>/etc/motd</B>.  And after
hacking away on them until they finally say <I>anything</I> besides the usual
brain-dead information about what kernel this is... you reboot.. <B>and there it 
is AGAIN!!</B>.  Arggghhh!

<P>So what happened?  There's a line of code in your /etc startup files that
resets the /etc/issue and /etc/motd files back to their original.  BTW... /etc/issue
is the first message that is displayed immediately before the login prompt, while
/etc/motd (Message Of The Day) is displayed once a user has successfully logged in.

<P>To fix this you'll need to edit one of those obscure config files in your
/etc/rc.d directory.  You'll need to edit /etc/rc.d/rc.S and look for:

<PRE>
# Setup the /etc/issue and /etc/motd to reflect the current kernel level:
# THESE WIPE ANY CHANGES YOU MAKE TO /ETC/ISSUE AND /ETC/MOTD WITH EACH
# BOOT. COMMENT THEM OUT IF YOU WANT TO MAKE CUSTOM VERSIONS.
echo > /etc/issue
echo Welcome to Linux `/bin/uname -a | /bin/cut -d\  -f3`. >> /etc/issue
echo >> /etc/issue
echo "`/bin/uname -a | /bin/cut -d\  -f1,3`. (POSIX)." > /etc/motd
</PRE>

If you look closely at what this does, it echo's several lines into your
/etc/issue file, thereby wasting whatever you'd previously written, and it does
the same with your /etc/motd file.  Now, thing to do is comment these out by
simply putting a &quot # &quot in the beginning of each of these lines.  Now,
you can go ahead and edit your <B>issue</B> and <B>motd</B> files and know that
when you boot up again... they'll be there!

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>
<A NAME="alias"><H2><IMG SRC="../gx/text.gif">Aliasing for fun and efficiency...</H2></A>

<P>While we're talking about fixing up boot up stuff... if you're using <B>bash</B> (which
most folks running Linux probably are since it's often installed by default) then
there's a great little config file you need to get aquainted with:

<P>Your ~/.bash_profile 

<P><B>Two cent tip:</B>  the squiggly-thingy (&quot <EM>tilde</EM> &quot) just
indicates your <EM>home</EM> directory.  It should point to the same directory that
the environment variable $HOME points to.

<P>If you browse the manpage for <B>bash</B> you'll discover that there are several
configuration files that can be read at the time of initialization
<UL>
<LI>/etc/profile -- the systemwide initialization file executed for login shells
<LI>~/.bash_profile -- the personal initialization file, executed for login shells
<LI>~/.bashrc -- the individual per-interactive-shell initialization file
</UL>
What this means is that you can set up your own personal initialization setup each
time you login.  <EM>And that's where aliases come in.</EM>

<P>Aliases are command substitutions, if you will, that can be used with certain
shells such as bash.  The syntax is:
<PRE>
	alias shortcut=`command -options`
</PRE>
Notice the use of the <CODE> "`" </CODE> after the equals sign (you know, the backwards
apostrophe that lives underneath the squiggly thingy on the top of the keyboard).

<P>Now... make life easier for yourself.  If you set up shortcut aliases you can
speed up your keyboard commands considerably.  Some examples:

<PRE>
alias c='clear'
alias d='ls -lF'
alias dir='ls -lF'
alias ftp='ftp -v'
alias lpr='lpr -h'
alias rm='rm -i'
alias startx='startx >& /dev/null'
alias x='startx >& /dev/null'
</PRE>

You'll notice that this speed things up a lot.  Instead of constantly typing out
ls -lF for a directory listing you simply enter &quot d &quot .  Also, if you're
running X Window <EM>and you're tired of looking at all the startup information
cluttering your screen when you shut it down</EM> then adding an alias to send
the usual stdout into the /dev/null bitbucket clears up your screen.  Nice and
tidy.

<P>Notice one other thing -- a safety point.  As long as you're not running as
root all the time you're probably safe from the standpoint of not fatally and
irretrievably zapping some critical system file.  But you can still effortlessly
do away with hours/days/weeks of work on a file if you inadvertently &quot rm &quot
something you hadn't intended.  UN*X can be kinda harsh, and Linux is no different.
Once somethings gone... it's gone.  Now there are programs that handle safe deletes,
but the plain vanilla Linux will still uncaringly discard anything you tell it to.

<P>By adding an alias for &quot rm &quot -- so that it is always invoked with the
-i option, it will always ask you for permission to delete something.  Yup, it's can
be a bit of an annoyance, but if it saves your butt once, you'll be happy that you
did.  Also, you <EM>can</EM> override this by issuing &quot rm -f delete_me.text &quot
and Linux will happily delete it without another thought.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="functions"><H2><IMG SRC="../gx/text.gif">Adding some functions for even more time savings</H2></A>

<P>Well, now that we've added some helpful aliases, let's make life even more fun 
and efficient...

<P>Adding functions to the ~/.bash_profile.

<P>Yup, you remember the idea of functions -- the short bits of little-black-box
code that takes in input and spits back some kind of output.  Well, you can set the
same basic thing up, only in a more modest fashion.  

<P>Under <B>bash</B> you can define functions that work in your shell script programs
by defining them like:

<PRE>
	Say_hello() 
	{
		echo "Hello world"
	}
</PRE>

Now, if you invoke the function Say_hello, you'll get a profound sense of accomplishment
as it issues a &quot Hello world &quot back.  Pretty lame, eh?  Well, not so fast.
You can use this bit of wizardry in your ~/.bash_profile to set up commonly used
functions.  Like what?  Well, if you use <B>tar</B> frequently, then it's helpful
to add something like:

<PRE>
	# Now, some handy functions...
	#
	tarc () { tar -cvzf $1.tar.gz $1 }
	tart () { tar -tvzf $1 | less }
	tarx () { tar -xvzf $1 $2 $3 $4 $5 $6 }
	popmail () { popclient -3 -v -u myname -p mypassword -o /root/mail/mail-in any.where.edu }
	zless () { zcat $* | less }
	z () { zcat $* | less }
</PRE>

to your ~/.bash_profile initialization file.  Now, instead of having to type out
<CODE>tar -xvzf some_very_long_filename-3.1415926535-bin-Motif-static.tar.gz</CODE>
you can just type in <CODE>tarx some_ver</CODE> (and then hit TAB to do a filename
completion... just because UN*X allows 256-character file names <EM>doesn't</EM> 
mean that you actually have to <EM>USE</EM> all 256 characters).  The function call
will do the rest.  An even handier situation is if you've got an excruciatingly long
command line to enter, such as for the program <B>popclient</B>.

<P>For short functions you can just as easily set up an alias.  Someone with more
UN*X wizardry than me might be able to say whether one is more efficient/desirable
than the other.  Fact is, they both work, and they'll both let you save a LOT of
time if your spending much time at the keyboard.

<P>One final point... you can use this basic idea to save yourself some harddrive
space.  How?

<P>If you <B>gzip -9</B> your documentation files (you probably don't want to do
this with your /etc/inittab file) then it's easy to view them by setting up a 
function or alias such as &quot z &quot , which is listed above.  This will <B>zcat</B>
the compressed file and pipe it to <B>less</B> (or <B>more</B> if you like that)
for viewing.  On my machine this action is nearly instantaneous for all but the most
gigantic files.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="au"><H2><IMG SRC="../gx/text.gif">Playing .AU stuff at boot up</H2></A>

<P>For any of you that have a sound card and have had the unfortunate pleasure of
firing up <EM>Windoze</EM> you'll recall the scratchy, irritating .wav <EM>noise</EM>
that eminates from your speakers.  This fingernails-on-the-chalkboard greeting reminds
you of what you have in store...

<P>Fortunately, you can do a lot better than the cheesy <CODE>ding.wav</CODE>
thing.  Linux is here to rescue you.  First, you'll need to get your hands on some
half-way decent .au files -- try the <B>multimedia</B> subdirectory at 
<A HREF="ftp://sunsite.unc.edu/pub/multimedia/sun_sounds/">sunsite.unc.edu</A>
for a veritable smorgasbord of great .au sound files.

<P>(In case you need some hints, there are great trekky clips, some wonderful stuff
by Monty Python -- try out spam.au and the lumberjack.au files -- as well as the
classics from the Three Stooges in the 
<A HREF="ftp://sunsite.unc.edu/pub/multimedia/sun_sounds/series/three_stooges/">
/series/three_stooges</A> subdirectory)

<P>Once you've gotten a few good .au files, you can make logging in a much more
rewarding and eventful experience by adding something like this to your /etc/rc.d/rc.local
file:

<PRE>
	cat /usr/local/sound/spam.au > /dev/audio &
</PRE>

If you put this at the end of the file, after all the other housekeeping chores are
done, then you'll be greeted with a rousing rendition of "Spam, Spam, Wonderful Spam"
in four part harmony (...honest!) as the login prompt is displayed.  One minor point --
don't forget to add the &quot &amp &quot at the end of the command line or else 
you'll find yourself having to sit throught the ENTIRE rendition before it gives up
control to the login prompt.  

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="mounting"><H2><IMG SRC="../gx/text.gif">Mounting your cdrom and floppies the <I>easy</I> way</H2></A>

<P>Ok, we're on a roll here...  While we're messing around with all the initialization
stuff it's time to hack away on something else.

<P>The <B>/etc/fstab</B> file.

<P>Here are just a couple suggestions to make life easier.

<P>First, for all of you who've upgraded to kernel 1.2.x and have suddenly found
yourself getting the same annoying error message at bootup... you know, something
about your /etc/fstab lacking a passno field entry... well, here's how to make
things right.

<P>The problem is that <B>mount</B> is now looking for two additional field in the
/etc/fstab file -- the fifth (fs freq) and the sixth (fs passno) fields -- which
are not, at least as yet, included by default in the stock <B>Slackware</B> distribution
of Linux.  So, after you've installed everything correctly, you <EM>still</EM>
end up getting an error message.  Time to fix it.

<P>The manpage for <B>fstab</B> is actually quite intelligible when it comes to
the entries.  What's important, at least to rid yourself of the annoying error 
message, is to know that two additional fields have been set up for each file
system entry.  The <B>fifth field</B> (fs freq)has to do with information regarding the
<B>dump</B> (?) program -- it specifies which filesystems need to be <B>dumped</B>.
(?) ... I'm not sure either, but I've read that it's safe to simply put in a 
&quot 0 &quot and let it go at that.

<P>The <B>sixth field</B> (fs passno) is the one of interest.  It contains a numerical value
used by the <B>fsck</B> program at boot time to determine the order in which filesystems
are checked. The rules are

<P><B>The root filesystem is given a value of 1</B><BR>
<B>Other filesystems are given a value of 2</B><BR>
<B>File systems that do not need checking -- such as the /proc or /cdrom -- are
given a value of 0</B>

<P>So, your fstab might look something like this:

<PRE>
 
# entries for file system table "fstab".  File systems are entered in a format:
#
# device:	mount:		fs-type: 	options:	dump:	fsck:
# _______	______		_______		________	____	____
#
/dev/hda6	/		ext2		defaults	0	1
/dev/hdb7	swap		swap		defaults	0	0
/dev/hda2	/dosc		msdos		defaults	0	2
/dev/hdb5	/os2		msdos		defaults	0	2
/dev/hdb6	/dosf		msdos		defaults	0	2
none		/proc		proc		defaults	0	0
#
# These last five are for the CDROM and floppy drives A and B.  The fs-type
# is indicated and the 'noauto' keeps init from trying to automount the fs
# at bootup.  The option 'user' *should* allow normal non-root users to mount
# the fs.
#
/dev/sbpcd	/cdrom		iso9660		ro,noauto	0	0
/dev/fd0	/a		msdos		user,noauto	0	0
/dev/fd1	/b		msdos		user,noauto	0	0
/dev/fd0	/fd0		ext2		user,noauto	0	0
/dev/fd1	/fd1		ext2		user,noauto	0	0

</PRE>

So what's going on here?

<P>When you boot your system, there's a line in your /etc/rc.d/rc.S file that
looks like:
<PRE>
	/sbin/mount -avt nonfs
</PRE>

at least this is what's in the plain vanilla Slackware distribution, your's may
vary.  The <B>mount</B> command with the <B>-a</B> option results in the automatic
mounting of all the filesystems in your /etc/fstab file <EM>execept those that 
have the noauto option</EM> .  

<P>So, if you look at what's going on, you'll see that in the above example, there
are several filesystems automatically mounted at boot time and include a Linux
native (/dev/hda6), a Linux swap (/dev/hdb7), a couple DOS partitions (/dev/hda2 and
/dev/hdb6), an OS/2 (FAT partition, hence the &quot msdos &quot fs-type) (/dev/hdb5)
and the /proc filesystem.

<P>What you'll also notice is that, in the lower section of the fstab file, there
are several stanza's with the &quot noauto &quot option indicated.  

<P><B>Here's where life get's easier</B>

<P>Adding the &quot noauto &quot option keeps <B>mount</B> from trying to mount
my cdrom or floppies at boot time -- since it's likely that there's nothing there.
However, when I'm ready to mount one of these, instead of having to type the usual

<P>mount -r -t iso9660 /dev/sbpcd /cdrom

<P>I can simply type in:

<P>mount /cdrom

<P>Mount will look in the fstab file and if it finds an entry for /cdrom it'll go
ahead and mount it with the options specified.  <B>Two other quick points</B>:
By setting up /a and /fd0 entries for /dev/fd0, and /b and /fd1 entries for /dev/fd1
I can easily mount floppies that are either in DOS or ext2 format by entering:

<P><B>mount /a</B> for DOS floppies or<BR>
<B>mount /fd0</B> for ext2 floppies

<P>And adding the &quot user &quot option allows me to mount the filesystem as a
<EM>non-root</EM> user.

<P>Slick, eh?  <B>Linux</B> is excellent.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="configs"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">Managing your wandering system configuration files</H2></A>

<P>I suspect that <EM>most people</EM> who are running Linux have found themselves,
for better or for worse, the <I>de facto</I> sysadmin of their workstation.  Yeah,
it's cool to be root but it can also be a major league <EM>pain-in-the-butt</EM> .

<P><B>Here's another two cent tip to make life easier.</B>

<P>If you've run Linux for any length of time you've probably ended up making a
<B>boatload of changes</B> to the system.  If you haven't done so already, you 
should probably made a subdirectory off your /root directory and put <B>copies of
ALL the system configuration files</B> that were installed by your distribution.

<P>So, you create a <B>/config_dist</B> subdirectory and start to collect some files:
<UL>
<LI>/etc/inittab
<LI>/etc/profile
<LI>/etc/rc.d/rc.*
<LI>/etc/passwd
<LI>/usr/X11R6/lib/X11/XF86Config
</UL>
then if the system crashes because you screwed something up, you've
got a backup copy to restore it to its original state.

<P>The prepared mind.

<P><B>One more suggestion...</B>

<P>After you've created a subdirectory to save all the original config files, create
another subdirectory called <B>/links</B>.  Now, for all of your widely scattered
configuration files, <EM>create symlinks for them in your /links directory.</EM>

<P>So, if you're messing around with trying to get your PPP setup going, make a link
to /etc/ppp/options or /usr/lib/ppp/pppon:

<PRE>
	cd ~/links
	ln -s /etc/ppp/options ppp_options
	ln -s /usr/lib/ppp/pppon pppon
</PRE>

Now, when you cd to your /links directory, you'll find symlinks to your various
config files.  Then, if you need to make any further changes in them, you can easily
do so from anywhere in your system by entering <B>vi ~/links/ppp_options</B>.  Having
all the system configuration files symlinked to one directory makes housekeeping a bit
easier.  Some further ideas about what to include:
<UL>
<LI>/etc/printcap -- if you've had to set up your printcap file
<LI>/var/spool/lpd/filter_myprinter -- if you've had to create an input filter
<LI>/etc/rc.d/rc.* -- pretty much <EM>all</EM> the stuff here
<LI>/usr/lib/ppp/ppp* -- <I>ibid.</I>
<LI>/usr/X11R6/lib/X11/fvwm/system.fvwmrc -- for all the groovy stuff you've done to FVWM
</UL>
and so forth.  You get the idea.  Every time you have to make an adjustment you go
throught this simple process:
<OL>
<LI>make a copy of the original file and call it original_filename<I>.dist</I>
<LI>copy that original_filename<I>.dist</I> to your /config_dist directory
<LI>make whatever alterations and customizations you want
<LI>make a symlink to your new-and-improved config file in your ~/links directory
<LI>now enjoy the fruits of your labors, or fix what you've just broken
</OL>

<P>Thing is... why go through all the bother of doing this <EM>by hand</EM> when
you can create a simple shell script that makes life MUCH easier.

<P><B>Two cent tip:</B>  if you have a long, repetitive task then think seriously
about writing a shell script to automate the process.  Remember:  you're not running
MSDOG, <B>this is Linux</B>.  Try something like:

<PRE>

#!/bin/sh
#
# program:	hack
# author:	johnMfisk	7 july 1995
# purpose:	create a backup and a symlink to an important system file.
#
CURR_DIR=`pwd`

cp $1 "/root/config_dist/$1.dist"
ln -s "$CURR_DIR/$1" "/root/links/$1"
vi $1
exit

</PRE>

<P>Don't forget to &quot <CODE>chmod 700 hack</CODE> &quot when you're done.  Then, every time
you need to alter a system configuration file, you simply enter in:

<P><B> hack important_sys_file.cfg</B>

<P>Hack creates a backup copy in your /config_dist directory with the
&quot .dist &quot suffix; then it creates a symlink to the file in your /links
directory; and finally, it fires up <B>vi</B> (or whatever other editor you like)
and let's you make your changes.  This is a pretty barebones example, and you could
easily spiff it up by, for instance, testing for the existance of the file in your
/config_dist directory and not copying over it if it already exists, or asking for
permission to copy over it.  

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="ext2tool"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">Accessing Linux from DOS!?</H2></A>

<P>Face it, a lot of folks who use Linux are actually converts from other OS's such
as DOS or Windoze.  And in reality, a lot of folks are actually in the <EM>multiple-OS</EM>
catagory.  There's a lot of software that we've spent good money on or just simply
like that either can't be run, or doesn't run well, under a non-native OS.  The
simple fact is, no one OS is perfect enough to run everything you'd like to run 
(and that goes <EM>double</EM> for Bill Gate$ and Co.)

<P>Fortunately, Linux comes with filesystem support for accessing your DOS FAT 
partitions.  It'll read from and write to your DOS filesystem.  There's also work
that's ongoing to provide both DOS emulation (<B>DOSEMU</B>) and Windows 3.1 emulation
(<B>WINE</B>) that would allow you to run your DOS and Win 3.1 programs directly from
Linux.  If you're interested in this kind of thing check out the
<A HREF="http://sunsite.unc.edu/mdw/linux.html">Linux Documentation Project</A>
web page for HOWTO's and other information.

<P>At present, there's a handy little program called
<A HREF="ftp://ftp.cc.gatech.edu/pub/linux/system/Filesystems/ext2/ext2tool.zip">
ext2tool.zip</A> written by <B>Claus Tondering</B>
that'll allow you to access your Linux files from DOS.  It's a 
bit shy in the looks department, but it seems reasonably sturdy and functional.
It supports the <B>ls, cd, cp, and cat</B> operations and includes a small
utility that helps identify your Linux partition number -- you'll need it to 
set up the E2CWD variable.

<P>To set it up simply unzip it into a directory, I put it in its own \ext2tool directory for
the sake of tidiness, and then follow the guidelines in the README file.  About the
only thing you'll need to do is set up the E2CWD variable:

<PRE>
[from the README]

Before you use the ext2 tools, you must set the environment variable
E2CWD using a statement similar to the following:

	SET E2CWD=129:5
or
	SET E2CWD=129:5:234

The three numbers after the equals sign are interpreted thus:

The first number (129 in the above example) identifies the physical
disk on which the ext2 file system is located. The number is used as
the second parameter to the DOS biosdisk() routine. Typical values
are:
	  0 for A: disk
	  1 for B: disk
	128 for first hard disk
	129 for second hard disk

(Your BIOS may use different values, especially if you have an SCSI
drive.)

The second number (5 in the above example) is the number of the disk
partition on which the ext2 file system is located. This number is
typically part of the Linux file name for the disk device.  If, for
example, you are used to referring to the disk as /dev/hdb5 under
Linux, the partition number is 5. The E2PART program can help you
identify the partitions.

The third number is the inode number of the directory that is to be
your current working directory. If this number is omitted, 2 (the root
inode number) is used. If you don't know what an inode is, don't worry.
Just omit the final number from E2CWD.
</PRE>

<P>Since my Linux partition is on the first harddrive and on the /dev/hda6
partition I just entered:

<P>SET E2CWD=128:6

<P>in my c:\autoexec.bat file and everything worked fine.

<P>It's actually easier than it looks and, once you've set things up, it works
pretty well.  As mentioned before, to get things <EM>back into Linux</EM> you'll
need to reboot and then copy it <EM>from</EM> from DOS since <B>ext2tool</B>
doesn't support writes.  But then again, who'd want to spend much time in DOS
anyway... ;-)

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR> 

<A NAME="kernel"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">Rolling your own kernel... it ain't that tough!</H2></A>

<P>For some people, the idea of compiling their own kernel gives them the willies and
wads their shorts in a knot.

<P>The good news is... it really ain't that tough.

<P>The reason is simple:  the guys who spend their time hacking away on the kernel
have done a pretty good job of making everything work right.  The actual task of
rolling your own kernel is <EM>technically</EM> quite simple.  There is, however, one
small

<P><B>Caveat:</B>  you have to know what you're doing.

<P>That said, let's see what you'll need to do in order to <EM>know what you're doing.</EM>
The heart of the matter is the step involving the &quot make config &quot procedure.
It's during this step that a script is run that asks you a series of questions about
what you want compiled into your kernel.  Options include

<UL>
<LI>math coprocessor emulation
<LI>various harddrive drivers
<LI>filesystem support
<LI>networking support
<LI>support for cdroms, bus mice, sound cards
</UL>

and so forth.  The script is intelligent enough to give you fairly reasonable
generic defaults.  The thing is, <EM>the reason to roll your own kernel is to 
provide it with only what YOU need for YOUR system.</EM>  

<P>If you have a Logitech bus mouse, a GUS sound card, and run a PPP dial-up
connection, then you really don't need support for NFS, Ethernet cards, or
cdrom drives.  If you answer one of the configuration questions incorrectly, it's
not that the kernel won't work... it will either have drivers included that you
can't use (kernel too large and takes up more memory), or it will lack some
option that you really need -- such as support for your bus mouse.

<P>So where do you go to learn?

<P>An excellent place to start is by reading <B>Brian Ward's</B> very helpful
<B>Kernel-HOWTO</B> which can be found, with an entire reference shelf of other
HOWTO's, on the 
<A HREF="http://sunsite.unc.edu/mdw/linux.html#howtos">
Linux Documentation Project's HOWTO</A> section.  Brian takes you through the
process step by step and explains what each of the options entails.  Another helpful
place to find information and advice is in the 
<A HREF="ftp://ftp.cc.gatech.edu/pub/linux/kernel/">Linux sunsite kernel</A>
directory.  Several authors have written programs specifically to assist with
compiling your own kernel.

<P>And don't forget printed material.  <B>Matt Welsh</B> and <B>Lar Kaufman</B>
have written an excellent book that needs to be on <EM>everyone's</EM> bookshelf
called <CITE>Running Linux</CITE> (Published by the folks at O'Reilly).  At 
$24.95 this is an absolute steal for over 500 pages of instruction, tips, tricks,
and step-by-step howto's.  If you don't have it, get it.

<P>Once you've done your homework, the technical part is quite straight forward:

<OL>
<LI>Get a current copy of the Linux kernel sources from, e.g., 
<A HREF="ftp://ftp.cc.gatech.edu/pub/linux/kernel/v1.2/">GA Tech's Linux archive</A>.
<LI>Untar it into the /usr/src directory.
<LI>Create a symlink from /linux-1.2.x to /linux -- e.g., <CODE>ln -s /linux-1.2.x linux</CODE>
<LI>Now, cd to the /usr/src/linux directory and you're ready to start.
</OL>

At this point you simply enter:

<P><B>make mrproper ; make config ; make dep ; make clean ; make zImage</B>

<P>That's it.  You'll see miles of script go whizzing by your screen and then a
series of questions will begin, asking you how you want your kernel configured --
you're in <B>make config</B>.  Answer the questions and when it's done it will
set about compiling your new kernel.  

<P>How long will it take?
<UL>
<LI>pentium/133 -- go to the bathroom but don't take too long.
<LI>pentium/66 -- run down and get a coke.
<LI>486DX2/66 -- run down and get a coke and flip through a magazine.
<LI>486SX/25 -- run down and get a coke, flip through a magazine, watch <EM>Cheers</EM>
reruns on the tube.
<LI>386DX40 -- run down and get a coke, flip through a magazine, watch <EM>Cheers</EM>
reruns on the tube, do a couple loads of wash.
<LI>386SX-16 -- run down and get a coke, flip through a magazine, watch <EM>Cheers</EM>
reruns on the tube, do a couple loads of wash, fly home to see your mom.
<LI>286 -- Uugh uugh, <EM>this dog don't hunt...</EM>
</UL>

Once the compile is done and you're through doing what you need to do, you can go
and pick up your shiny new kernel in:

<P>/usr/src/linux/arch/i386/boot

<P>It'll be called <CODE>zImage</CODE> and is usually at the bottom of your directory
listing.  There you go!  you've done it!  

<P>Now I'll bet you want to try it out, eh?  First, a couple <B>caveats!</B>

<P><B>Caveat #1</B>:  make absolutely sure you have a working boot disk <EM>before</EM>
you do anything else.

<P><B>Caveat #2</B>:  make sure the boot disk actually <EM>works!</EM>

<P><B>Caveat #3</B>:  make a backup copy of your current working kernel image (usually,
/vmlinuz) and put it in a safe place.

<P>Now, rename you current kernel image -- e.g., <CODE>mv vmlinuz vmlinuz.bak</CODE>
and then copy the new zImage kernel to the root partition or wherever you put your
kernel images -- e.g., <CODE>cp zImage /vmlinuz.</CODE>

<P>You may need to <CODE>chmod 400 vmlinuz</CODE> to set the proper permissions and
then <B>don't forget to rerun LILO!</B> -- e.g., /sbin/lilo.  Once you've done all
this, you're ready to reboot.

<P>Ok, go ahead... you can do the old <CODE>shutdown -r now</CODE> and keep your 
fingers crossed!  

<P><B>It didn't work??!!!  Arrgghhh...!!</B>  But don't fret, it's fixable.  If your
system yurks up on your new kernel for some reason simply reboot using your boot
floppy and then copy your old kernel image, which you put in a safe place, back
into the root directory and <B>rerun LILO</B> -- e.g., /sbin/lilo.  

<P>You should now have your old kernel image safely in place and can reboot your
system off the harddrive once again.  But keep reading... we'll look at some ideas
for <EM>safely and easily test driving a new kernel</EM> in the next section.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="testdrive"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">Test driving your kernel the <I>safe</I> way</H2></A>

<P>Now that you've had a run at compiling your own kernel, it's time to try it out
and see whether it actually works.  Simply copying over your trusty old kernel is...
well, maybe just a bit brash, unless you <EM>really</EM> know what you're doing, or
you <EM>really</EM> are a thrill-seeker.  If you're either of the above you can probably
stop reading here.

<P>For the rest of you, keep reading.

<P>There are two rather easy ways to try out your new kernel:
<UL>
<LI>making a boot disk from it
<LI>setting it up as a LILO boot option
</UL>
There are, to be sure, more sophisticated ways of testing out your new kernel...
but this ain't gurudom, it's simply what works.  And either of these two methods
should give you the chance to try booting a new kernel without incurring too much
trouble in the process.

<P>To create a useable boot disk simply copy the <B>zImage</B> file that's in
your /usr/src/linux/arch/i386/boot/ directory to a floppy:

<PRE>
	cp zImage /dev/fd0
</PRE>
to install it onto a disk in your first floppy drive.  Keep in mind that this is
a <EM>bit</EM> of a kludge as it will wipe out any filesystem that exists on the
disk.  It also goes without saying that you'll want to do this on a floppy that
doesn't have any important stuff on it.  Copying this to the floppy that had your
327 page doctoral dissertation in LaTeX2e format on it is probably not a good 
idea.

<P>Then, to try it out just reboot with the usual <B>shutdown -r now</B> and sit
back and enjoy.  Keep an eye out for any error messages that may crop up during
the boot process.  There is a utility you should be aware of if you're messing
around with kernels -- <B>rdev</B>, which allows you to set certain boot time
options for the kernel.  These include such things as which partition to set up
as the root partition and as the swap partition, the root flags (read/write or
read only), the bootup videomode, the ramdisk size, and the byte offset to use.
You'll probably <B>not</B> need to adjust your kernel as it will likely point to
the correct root partition.  If it doesn't, then you can enter:

<PRE>
	rdev /dev/fd0 /dev/hda6
</PRE>
for example, if your root partition is, in fact, the /dev/hda6 partition.
You might, however, want to issue the command:

<PRE>
	rdev -R /dev/fd0 1
</PRE>
This sets the root partition as <EM>read-only</EM> at boot time so that the
filesystem can be checked prior to being mounted.  If you forget the exact
syntax of the command entering <CODE>rdev -h</CODE> will  pop up a short
help screen to jog your memory.

<P>Now, once you know for sure that your new kernel works -- it actually let's you
mount your new CDROM, or dial up your PPP link -- you can go ahead and make a 
back up copy of your trusty old kernel, put it in a safe place, and copy your
zImage file into your root directory.  And <B>don't forget to run LILO</B> -- i.e.,
enter <CODE>/sbin/lilo</CODE> at the command prompt.  If you don't, and you're
using LILO as your boot manager, you probably will not be able to boot your new
kernel, even if it works correctly.

<P>The other method is to simply add a stanza to your lilo.conf file that will
let you choose to boot either your usual kernel (often, /vmlinuz in your root
directory) or a new kernel you've just compiled.  

<P>You'll need to edit your <B>/etc/lilo.conf</B> file.  It might look something like:

<PRE>
# LILO configuration file
#
# Start LILO global section
append="sbpcd=0x230,SoundBlaster"	# this is for my SoundBlaster CDROM
boot = /dev/hda6			# name of device where LILO installs itself
#compact        			# faster, but won't work on my system.
delay = 5				# wait time
vga = normal    			# force sane state
ramdisk = 0     			# paranoia setting
# End LILO global section
#
# My normal Linux set-up -- boot from /vmlinuz
#
image = /vmlinuz			# normal kernel in root directory
  root = /dev/hda6			# my root partition
  label = Linux				# boot time label
  read-only 				# Non-UMSDOS filesystems should be mounted read-only for checking
#
# Stanza to allow test driving of new kernel images
#
image = /usr/src/linux/arch/i386/boot/zImage
  root = /dev/hda6
  label = zImage			# what I'll call the test kernel
  read-only				# Same as above
# Linux bootable partition config ends
</PRE>

Suffice it to say that configuring LILO, and actually getting it to work, can be
a bit hairy at times.  This is one file you <EM>definitely</EM> want to have a boot
disk and a backup copy of before you blithely wander in where angels fear to tread.
Having done that, however, you should only have to make minor additions to your 
/etc/lilo.conf file to get things working.

<P>What you'll need to add are primarily in the last 5 lines of the example above.
You'll need to add a stanza for the new test kernel.  The <I>image</I> entry
indicates where the kernel image is located.  In this case, it points to the
directory where the new kernel is found after you've compiled a kernel with the <B>make zImage</B> command.
Kinda tidy, eh?  

<P>The only other required entry is the <EM>label</EM>, which is what LILO will
use when it asks you what you want to boot.  The remainder of the entries, such
as <EM>root</EM> or <EM>vga</EM> can be left out and the options included at
compile time or set using <B>rdev</B> will be used.  If you're a bit on the timid
side and don't want to hack away too much, you can safely enter just the
<EM>image</EM> and the <EM>label</EM> entries and things should work all right.
Last, but not least, <B>don't forget to rerun LILO</B> -- i.e., simply enter 
<CODE>/sbin/lilo</CODE> at the command prompt and you should see something like:

<PRE>
Adding Linux *
Adding zImage
</PRE>

<P>Now, after you reboot, simply hold down the <B>Shift</B> key as LILO starts up
and it'll prompt you for which kernel you'd like to boot.  Hitting the <B>Tab</B>
key will present you with a list of options.  So... go ahead and enter <B>zImage</B>
and, if everything went as planned, <I>voila</I>!  a new kernel.  Using either of
these methods allows you to try booting a new kernel without disturbing your present
setup.  If things don't work you can either remove your test boot floppy or tell
LILO to boot from your previous kernel.

<BR><BR>
<A HREF="#toc"><IMG ALIGN=BOTTOM SRC="./gx/toc.gif"></A>
<A HREF="mailto: fiskjm@ctrvax.vanderbilt.edu"><IMG ALIGN=BOTTOM SRC="./gx/sendmail.gif"></A>
<A HREF="./gazette_toc.html"><IMG ALIGN=BOTTOM SRC="./gx/index.gif"></A>
<A HREF="./linux/linux.html"><IMG ALIGN=BOTTOM SRC="./gx/home.gif"></A>
<BR><BR>

<HR>

<A NAME="thatsit"><H2><IMG ALIGN=BOTTOM SRC="../gx/text.gif">Well, that's it!</H2></A>

<P>Hope you enjoyed this premier issue of the <B>Linux Gazette</B>.  I've tried to
make every effort to ensure that the information presented here is up to date and
correct.  Please let me know if there are any glaring oversights or errors in this.
Also, if you have suggestions, comments, or critisms let me know.

<P>If there's any interest in this, I'd be happy to keep writing new editions.

<BR>

<HR>

<H4>Got any <I>great</I> ideas for improvements!  Send your
<A HREF="mailto:fiskjm@ctrvax.vanderbilt.edu">comments, criticisms, suggestions, and ideas.</H4>

<BR>
<A HREF="linux/linux.html"><IMG ALIGN=BOTTOM SRC="../gx/back.gif"> Back up to Linux HomeBoy WebPage</A> <BR>
<BR>

<I>This page written and maintained by:</I><BR>
<ADDRESS> 
<A HREF="jmf.html">John M. Fisk</A> at <A HREF="mailto:fiskjm@ctrvax.vanderbilt.edu">
fiskjm@ctrvax.vanderbilt.edu</A>
</ADDRESS> 

</BODY>
</HTML>
