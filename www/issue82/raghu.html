<!--startcut  ==============================================-->
<!-- *** BEGIN HTML header *** -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<title>Writing your own Toy OS - Part III LG #82</title>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#0000AF"
ALINK="#FF0000">
<!-- *** END HTML header *** -->

<!-- *** BEGIN navbar *** -->
<IMG ALT="" SRC="../gx/navbar/left.jpg" WIDTH="14" HEIGHT="45" BORDER="0" ALIGN="bottom"><A HREF="qubism.html"><IMG ALT="[ Prev ]" SRC="../gx/navbar/prev.jpg" WIDTH="16" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="index.html"><IMG ALT="[ Table of Contents ]" SRC="../gx/navbar/toc.jpg" WIDTH="220" HEIGHT="45" BORDER="0" ALIGN="bottom" ></A><A HREF="../index.html"><IMG ALT="[ Front Page ]" SRC="../gx/navbar/frontpage.jpg" WIDTH="137" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><IMG ALT="[ Talkback ]" SRC="../gx/navbar/talkback.jpg" WIDTH="121" HEIGHT="45" BORDER="0" ALIGN="bottom"  ><A HREF="../lg_faq.html"><IMG ALT="[ FAQ ]" SRC="./../gx/navbar/faq.jpg"WIDTH="62" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="shekhar.html"><IMG ALT="[ Next ]" SRC="../gx/navbar/next.jpg" WIDTH="15" HEIGHT="45" BORDER="0" ALIGN="bottom"  ></A><IMG ALT="" SRC="../gx/navbar/right.jpg" WIDTH="15" HEIGHT="45" ALIGN="bottom">
<!-- *** END navbar *** -->

<!--endcut ============================================================-->

<TABLE BORDER><TR><TD WIDTH="200">
<A HREF="http://www.linuxgazette.net/">
<IMG ALT="LINUX GAZETTE" SRC="../gx/2002/lglogo_200x41.png" 
	WIDTH="200" HEIGHT="41" border="0"></A> 
<BR CLEAR="all">
<SMALL>...<I>making Linux just a little more fun!</I></SMALL>
</TD><TD WIDTH="380">


<center>
<BIG><BIG><STRONG><FONT COLOR="maroon">Writing your own Toy OS - Part III</FONT></STRONG></BIG></BIG><BR>
<STRONG>By <A HREF="mailto:raghu4jm@yahoo.com">Raghu and Chitkala</A></STRONG></BIG>

</TD></TR>
</TABLE>
<P>

<!-- END header -->


<BLOCKQUOTE><EM>
	[Krishnakumar is unable to continue this series himself due to other
	commitments, so he has handed it over to his junior colleagues,
	Raghu and Chitkala, who have written part III. -Editor.]
	</EM></BLOCKQUOTE>

<p>
In Parts <A HREF="../issue77/krishnakumar.html">I</A> and <A
HREF="../issue79/krishnakumar.html">II</A> of this series, we examined the
process of using tools available with Linux to build a simple boot sector and
access the system BIOS.  Our toy OS will be closely modelled after a `historic'
Linux kernel - so we have to switch to protected mode real soon! This part
shows you how it can be done.

<h2>1. What is <u>Protected Mode </u>?</h2>

<p>The 80386+ provides many new features to overcome the
deficiencies of 8086 which has almost no support for memory
protection, virtual memory, multitasking, or memory above 640K -
and still remain compatible with the 8086 family. The 386 has all
the features of the 8086 and 286, with many more enhancements. As
in the earlier processors, there is the real mode. Like the 286,
the 386 can operate in protected mode. However, the protected
mode on 386 is vastly different internally. Protected mode on the
386 offers the programmer better protection and more memory than
on the 286. The purpose of protected mode is not to protect your
program. The purpose is to protect everyone else (including the
operating system) from your program.</p>

<h2>1.1 Protected Mode vs Real Mode</h2>

<p>Superficially protected mode and real mode don't seem to be
very different. Both use memeory segmentation, interrupts and
device drivers to handle the hardware. But there are differences
which justify the existence of two separate modes. In real mode,
we can view memory as 64k segments atleast 16bytes apart.
Segmentation is handled through the use of an internal mechanism
in conjunction with segment registers. The contents of these
segment registers (CS,DS,SS...) form part of the physical address
that the CPU places on the addresss bus. The physical address is
generated by multiplying the segment register by 16 and then
adding a 16 bit offset. It is this 16 bit offset that limits us
to 64k segments.</p>

<p><em><strong>fig 1 : Real Mode Addressing </strong></em></p>

<p><img src="misc/raghu/fig1.png" width="349"
height="138"></p>

<p>In protected mode, segmentation is defined via a set of tables
called descriptor tables. The segment registers contain pointers
into these tables. There are two types of tables used to define
memory segmentation : The Global Descriptor Table and The Local
Descriptor Table. The GDT contains the basic descriptors that all
applications can access. In real mode one segment is 64k big
followed by the next in a 16 byte distance. In protected mode we
can have a segment as big as 4Gb and we can put it wherever we
want. The LDT contains segmentation information specific to a
task or program. An OS for instance could set up a GDT with its
system descriptors and for each task an LDT with appropriate
descriptors. Each descriptor is 8 bytes long. The format is given
below (fig 3). Each time a segment register is loaded, the base
address is fetched from the appropriate table entry. The contents
of the descriptor is stored in a programmer invisible register
called shadow registers so that future references to the same
segment can use this information instead of referencing the table
each time. The physical address is formed by adding the 16 or 32
bit offset to the base address in the shadow register.These
differences are made clear in figures 1 and 2.</p>

<p><em><strong>fig 2 : Protected Mode Addressing</strong></em></p>

<p><img src="misc/raghu/fig2.png" width="436"
height="233"></p>

<p><em><strong>fig 3 : Segment Descriptor Format</strong></em></p>

<p><img src="misc/raghu/fig3.png" width="432"
height="130"></p>

<p>We have yet another table called the interrupt descriptor
table or the IDT. The IDT contains the interrupt descriptors.
These are used to tell the processor where to find the interrupt
handlers. It contains one entry per interrupt, just like in Real
Mode, but the format of these entries is totally different. We
are not using the IDT in our code to switch to the protected mode
so further details are not given. </p>

<h2>2. Entering Protected Mode</h2>

<p>The 386 has four 32 bit control registers named CR0, CR1, CR2
and CR3. CR1 is reserved for future processors, and is
undefined for the 386. CR0 contains bits that enable and
disable paging and protection and bits that control the
operation of the floating point coprocessor. CR2 and CR3 are
used by the paging mechanism. We are concerned with bit 0 of the
CR0 register or the PE bit or the protection enable bit. When PE
= 1, the processor is said to be operating in protected mode with
the segmentation mechanism we described earlier. If PE = 0, the
processor operates in real mode. The 386 also has the
segmentation table base registers like GDTR, LDTR and
IDTR.These registers address segments that contain the descriptor
tables. The GDTR points to the GDT. The 48 bit GDTR defines the
base and the limit of the GDT directly with a 32 bit linear
address and a 16 bit limit.</p>

<p>Switching to protected mode essentially implies that we set
the PE bit. But there are a few other things that we must do. The
program must initialise the system segments and control
registers. Immediately after setting the PE bit to 1 we have to
execute a jump instruction to flush the execution pipeline of any
instructions that may have been fetched in the real mode. This
jump is typically to the next instruction. The steps to switch to
protected mode then reduces to the following :</p>

<ol>
    <li>Build the GDT.</li>
    <li>Enable protected mode by setting the PE bit in CR0.</li>
    <li>Jump to clear the prefetch queue.</li>
</ol>

<p>We'll now give the code to perform this switching. </p>

<h2>3. What we need </h2>

<ul>
    <li>a blank floppy</li>
    <li>NASM assembler</li>
</ul>

<p>
<a href="misc/raghu/code.asm.txt">Click here</a> to download the code.
Type in the code to a file by name abc.asm. 
Assemble it by typing the command <strong>nasm abc.asm</strong>.
This will produce a file called abc. Then insert the floppy and
type the following command <strong>dd if=abc of=/dev/fd0.</strong>
This command will write the file abc to the first sector of the
floppy. Then reboot the system. You should see the following
sequence of messages.</p>

<ul>
    <li>Our os booting........................</li>
    <li>A (Brown colour)</li>
    <li>Switching to protected mode....</li>
    <li>A (White colour)</li>
</ul>

<h2>4. The Code that does everything !</h2>

<p>We'll first give the code to perform the switching. It is
followed by a detailed explanation. </p>

<p>As mentioned in the previous article (Part 1) the BIOS selects 
the boot device and places the first sector into the address 0x7c00.
We thus start writung our code at 0x7c00.This is what is implied by 
the org directive.</p>

<h2>FUNCTIONS USED</h2>

<p><strong>print_mesg</strong>: This routine uses the subfunction 13h 
of BIOS interrupt 10h to write a string to the screen.The attributes 
are specified by placing appropriate values in various registers.
Interrupt 10h is used for various string manipulations.We store the 
subfn number 13h in ah which specifies that we wish to print a string.
Bit 0 of the al register determines the next cursor position;if it is 
0 we return to the beginning of the next line after the function call,
if it is 1 the cursor is placed immediately following the last 
character printed.</p>

<p>The video memory is split into several pages called 
video display pages.Only one page can be displayed at a time(For 
further details on video memory refer Part 1).The contents of bh 
indicates the page number,bl specifies the colour of the character to
be printed. cx holds the length of the string to be printed.Register 
dx specifies the cursor position. Once all the attributes have been 
initialised we call BIOS interrupt 10h.</p>

<p><strong>get_key</strong>: We use BIOS interrupt 16h whose sub 
function 00h is used to get the next character from the screen.
Register ah holds the subfn number.</p>

<p><strong>clrscr</strong>: This function uses yet another subfn of 
int 10h i.e 06h to clear the screen before printing a string.To 
indicate this we initialise al to 0.Registers cx and dx specify the 
window size to be cleared;in this case it is the entire screen.
Register bh indicates the colour with which the screen has to be 
filled;in this case it is black.</p>

<h2><strong>Where everything begins !!</strong></h2>
<p>The first assembly language statement is a short jump to the 
begin_boot code.We intend to print a brown 'A'in real-mode,set up a 
GDT,switch to protected mode and print a white 'A'.Both these modes 
use their own addressing methods.</p>

<p><strong>In Real-Mode</strong> :</p>
<p>We use segment register gs to point to video memory.We use a CGA 
adapter(default base address 0xb8000).But hey we have a missing 0 in 
the code.Well the Real-mode segmentation unit provides the additional 
0.This is a matter of convenience,as the 8086  usually does a 20bit 
address manipulation.This has been carried over in the real-mode 
addressing of the 386.The ascii value for A is 0x41;0x06 specifies 
that we need a brown coloured character.The display stays till we 
press a key.Next let us display a message on the screen saying we are 
going to the world of protected mode.So let us point the bp(base 
pointer register to the message to be printed).</p>

<p><strong>Launchpad to the protected mode</strong> :</p>
<p>We don't need any interrupts bothering us,while in protected mode 
do we ?So lets disable them(interrupts that is).That is what cli does.
We will enable them later.So lets start by setting up the GDT.We 
initialise 4 descriptors in our attempt to switch to protected mode. 
These descriptors initialise our code segment(code_gdt), data and stack 
segments (data_gdt) and the video segment in order to access the video 
memory. A dummy descriptor is also initialised although it's never 
used except if you want to triple fault of course. This is a null 
descriptor. Let us probe into some of the segment descriptor fields.
</p>
<ul>
<li> The first word holds the limit of the segment, which for 
     simplicity is assigned the maximum of FFFF(4G). For the video 
     segment we set a predefined value of 3999 (80 cols * 25 rows 
     * 2bytes - 1).</li>
<li> The base address of the code and data segments is set to 0x0000.
     For the video segment it is 0xb8000 (Video Memory base address).
</li>
</ul>

<p> The GDT base address has to be loaded into GDTR system register.
The gdtr segment is loaded with the size of the GDT in the first word 
and the base address in the next dword. The lgdt instruction then loads
the gdt segment into the GDTR register.Now we are ready to actually 
switch to pmode. We start by setting the least significant bit of CR0
to 1( ie the PE bit).We are not yet in full protected mode!</p>

<p>Section 10.3 of the INTEL 80386 PROGRAMMER'S REFERENCE MANUAL 1986 
states : Immediately after setting the PE flag,the initialization 
code must flush the processor's instruction prefetch queue by 
executing a JMP instruction.The 80386 fetches and decodes instructions
and addresses before they are used; however, after a change into 
protected mode, the prefetched instruction information (which pertains
to real-address mode) is no longer valid. A JMP forces the processor 
to discard the invalid information.</p>

<p>We are in protected mode now. Want to check it out? Let's get our 
A printed in white. For this we initialise the data and extra segments 
with the data segment selector (datasel). Initialise gs with the video
segment selector (videosel). To display a white 'A' move a word 
containing the ascii value and attribute to location [gs:0000] ie 
b8000 : 0000. The spin loop preserves the text on the screen until 
the system is rebooted.</p>

<p>The times instruction is used to fill in 0s in the remaining 
unused bytes of the sector.To indicate that this is a bootable sector
we write AA55 in bytes 511,512. That's about all. </p>





<!-- *** BEGIN bio *** -->
<P>
<H4><IMG ALIGN=BOTTOM ALT="" SRC="../gx/note.gif">Raghu and Chitkala</H4>
<EM>Raghu and Chitkala are seventh-semester students at the Government
Engineering College, Thrissur, India.  Their final-year project is porting User
Mode Linux to BSD. Their interests include Operating Systems, Networking and
Microcontrollers.</EM>
<!-- *** END bio *** -->

<!-- *** BEGIN copyright *** -->
<hr>
<CENTER><SMALL><STRONG>

Copyright &copy; 2002, Raghu and Chitkala.
Copying license <A HREF="../copying.html">http://www.linuxgazette.net/copying.html</A><BR> 
Published in Issue 82 of <i>Linux Gazette</i>, September 2002</H5>
</STRONG></SMALL></CENTER>
<!-- *** END copyright *** -->
<HR>

<!--startcut ==========================================================-->
<CENTER>
<!-- *** BEGIN navbar *** -->
<IMG ALT="" SRC="../gx/navbar/left.jpg" WIDTH="14" HEIGHT="45" BORDER="0" ALIGN="bottom"><A HREF="qubism.html"><IMG ALT="[ Prev ]" SRC="../gx/navbar/prev.jpg" WIDTH="16" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="index.html"><IMG ALT="[ Table of Contents ]" SRC="../gx/navbar/toc.jpg" WIDTH="220" HEIGHT="45" BORDER="0" ALIGN="bottom" ></A><A HREF="../index.html"><IMG ALT="[ Front Page ]" SRC="../gx/navbar/frontpage.jpg" WIDTH="137" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><IMG ALT="[ Talkback ]" SRC="../gx/navbar/talkback.jpg" WIDTH="121" HEIGHT="45" BORDER="0" ALIGN="bottom"  ><A HREF="../lg_faq.html"><IMG ALT="[ FAQ ]" SRC="./../gx/navbar/faq.jpg"WIDTH="62" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="shekhar.html"><IMG ALT="[ Next ]" SRC="../gx/navbar/next.jpg" WIDTH="15" HEIGHT="45" BORDER="0" ALIGN="bottom"  ></A><IMG ALT="" SRC="../gx/navbar/right.jpg" WIDTH="15" HEIGHT="45" ALIGN="bottom">
<!-- *** END navbar *** -->
</CENTER>
</BODY></HTML>
<!--endcut ============================================================-->
