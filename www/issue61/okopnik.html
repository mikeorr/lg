<!--startcut  ==============================================-->
<!-- *** BEGIN HTML header *** -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<title>Learning Perl, part 1 LG #61</title>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#0000AF"
ALINK="#FF0000">
<!-- *** END HTML header *** -->

<CENTER>
<A HREF="http://www.linuxgazette.net/">
<H1><IMG ALT="LINUX GAZETTE" SRC="../gx/lglogo.jpg" 
	WIDTH="600" HEIGHT="124" border="0"></H1></A> 

<!-- *** BEGIN navbar *** -->
<IMG ALT="" SRC="../gx/navbar/left.jpg" WIDTH="14" HEIGHT="45" BORDER="0" ALIGN="bottom"><A HREF="nielsen2.html"><IMG ALT="[ Prev ]" SRC="../gx/navbar/prev.jpg" WIDTH="16" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="index.html"><IMG ALT="[ Table of Contents ]" SRC="../gx/navbar/toc.jpg" WIDTH="220" HEIGHT="45" BORDER="0" ALIGN="bottom" ></A><A HREF="../index.html"><IMG ALT="[ Front Page ]" SRC="../gx/navbar/frontpage.jpg" WIDTH="137" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><IMG ALT="[ Talkback ]" SRC="../gx/navbar/talkback.jpg" WIDTH="121" HEIGHT="45" BORDER="0" ALIGN="bottom"  ><A HREF="../faq/index.html"><IMG ALT="[ FAQ ]" SRC="./../gx/navbar/faq.jpg"WIDTH="62" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="padala.html"><IMG ALT="[ Next ]" SRC="../gx/navbar/next.jpg" WIDTH="15" HEIGHT="45" BORDER="0" ALIGN="bottom"  ></A><IMG ALT="" SRC="../gx/navbar/right.jpg" WIDTH="15" HEIGHT="45" ALIGN="bottom">
<!-- *** END navbar *** -->
<P>
</CENTER>

<!--endcut ============================================================-->

<H4 ALIGN="center">
"Linux Gazette...<I>making Linux just a little more fun!</I>"
</H4>

<P> <HR> <P> 
<!--===================================================================-->

<center>
<H1><font color="maroon">Learning Perl, part 1</font></H1>
<H4>By <a href="mailto:ben-fuzzybear@yahoo.com">Ben Okopnik</a></H4>
</center>
<P> <HR> <P>  

<!-- END header -->




<p>If you've been using Linux for any length of time, you've surely heard
of Perl; probably even run a number of scripts, perhaps without even knowing
it. Programs like "inews", "mirror", "debconf", "majordomo", "sirc", and
a host of others are written purely in Perl. Taking a quick "zgrep" through
the "Packages.gz" file in the Debian distro tells me that 382 of the packages
depend on Perl (meaning that a critical part of that package is written
in it), and 28 other packages either suggest or recommend it.
<br>&nbsp;
<p><b>So, What's It Good For?</b>
<p><tt>"Perl is great at text-processing, and it's great at tying and integrating
things together. To a scripting language, all those different elements
look the same."</tt>
<br><b><tt><font size=-1>&nbsp;-- John Ousterhout, author of the Tcl scripting
language</font></tt></b>
<p>"Perl" is supposed to stand for the "Practical Extraction and Report
Language". Right: bo-oring, but I guess that's what you've got to have
if you're going to convince $HUMONGOUS_CORP to use it. Actually, Larry
Wall <tt>&lt;larry@wall.org&gt;</tt> (the author of Perl) says in the Perl
man page: "Perl actually stands for Pathologically Eclectic Rubbish Lister,
but don't tell anyone I said that." Umm... OK, Larry. Not a word out of
me.
<p>Perl has been variously referred to as "A scripting language with delusions
of full language-hood", "The Swiss Army Chainsaw of Unix", "The duct tape
of the Web", and other equally, umm, complimentary names. It has been used
to write single-line scripts, fast-executing programs, large projects (Amazon.com's
entire editorial production and control system, Netscape's content management
and delivery system, the Human Genome Project's DNA sequencing and project
management, etc.), and millions of quick programs that do an amazing variety
of things.&nbsp; Perl can also emulate a number of common Unix system utilities
(hint: if you're looking at having to learn 'awk', 'sed', 'grep', and 'tr',
I'd suggest starting in on Perl, instead. All the functionality, much faster,
and you'll never outgrow the capabilities. Sure wish I'd known that, way
back when...)
<p>As you would expect of any modern language, Perl allows you to do object-oriented
programming. It also handles networking (sockets, etc.), is highly portable
(a well-written script will run on Linux, BSD, Solaris, DOS, Win9x, NT,
MacOS, OS/2, AmigaOS, VMS, etc. without modification), and has a very short
write/debug cycle - since there's no compilation required, you just write
the changes and run the script. There's a tremendous wealth of modules
(pre-built Perl routines) available to perform just about any task; the
Comprehensive Perl Archive Network (CPAN) is one of the best resources
a Perl programmer can have.
<br>&nbsp;
<p><b>Yeah, But What Is It <u>Really</u>?</b>
<p>Good question. I hope that, after using it for a year or so, <b>you</b>
can tell <b>me</b>. A description of anything is a container... and I'm
still trying to find one big enough to fit Perl (preferably one with a
strong lockable lid.)
<br>&nbsp;
<p><b>What Kind Of Things <u>Isn't</u> Perl Good For?</b>
<p>Hmmm. I wouldn't set out to write a GUI word processor, a video game,
or a graphic browser in it. Perl can indeed do glitzy front ends via its
interfaces to many other languages, so you <u>could</u> do all of those
things - but in my opinion, there are more efficient ways to do them in
other languages. "To a man with a hammer, every problem looks like a nail"
- let the programmer beware!
<p>Note, also, that Perl itself isn't written in Perl; neither is the Linux
kernel. Low-level stuff of that sort is best left to C/C++ with some assembler
thrown in; 'the right tools for the right job' should be every programmer's
motto.
<br>&nbsp;
<p><b>One Final Warning Before Pulling The Ripcord</b>
<p>If you know a bit of Perl, and see something in this series that 'Aint
The Way I Larned It', just remember Perl's motto: There's More Than One
Way To Do It. Usually abbreviated TMTOWDI, and pronounced "tim-today",
it is a core philosophy of Perl. Of course, corrections of any obvious
errors are welcome.
<p>

<p>Those of you who read my earlier series on shell scripting may remember
that a script starts out with the so-called "hash-bang" or "shebang" line:
<p><tt>#! /bin/bash</tt>
<p>This tells the shell to spawn a subshell in which the following code
will be executed by the specified program. This is also what's needed for
Perl scripts - the first line must be
<p><tt>#! /usr/bin/perl</tt>
<p>or whatever is the correct path to your "perl" executable.
<p>Note the requirements for a hash-bang:
<p><b>1) It must be the first line in the script.</b>
<br><b>2) The hash (#) must be the first character on the line, and there</b>
<br><b>&nbsp;&nbsp; cannot be anything between it and the bang (!).</b>
<br><b>3) You must use the absolute path, not just the executable name.</b>
<p>So, let's try writing our first Perl script:
<p>

<br><tt>#!/usr/bin/perl</tt>
<br><tt># "goodbye" - a modern, high-angst replacement for "Hello World"</tt>
<p><tt>print "Goodbye, cruel world!\n";</tt>
<br><tt>unlink $0;</tt>
<br>

<p>Well... at least it says "goodbye" before going away; Ms. Manners would
be proud. What did we do here? Several things that are rather obvious:
first, the "hash-bang"; next, a line that tells us what the script does
- another thing that carries over from shell scripting, and is an excellent
idea (there's no such thing as too many comments in the code!) Next, we
print the message using the `print' function. Note the "\n" at the end
of the string: Perl does not automatically provide you with a line-feed,
so you get to decide whether you want one or not. Also, note the semi-colon
at the end of the statement: just like C, Perl demands those, and Woe Betide
The Hapless Programmer Who Forgets! Actually, Perl's error checking is
pretty good stuff, with relatively readable messages; it's just that semicolons,
being statement separators, often cause the error to be reported as being
on the next line down. If you're aware of that quirk, it's not a big deal.
Better yet, just remember to use the semicolons.
<p>The last line is what does the evil deed of erasing the file - "goodbye
cruel world" indeed. The "$0" is simply a reference to the name of the
script being executed, and "unlink" does the same thing as "rm". Note that
"$0" is a lot more useful than "goodbye" or even "./goodbye" - no matter
what the file has been named, "$0" returns that name.
<br>&nbsp;
<p><b>Oh, By The Way: Some Code Guidelines</b>
<p>Far be it from me to claim perfection in writing code: on past occasion,
I've done "write-only" code that would make anyone trying to read it turn
various colors. The thing is, I'm constantly trying to improve - and I'd
surely like to see that idea take hold.
<p>Perl treats "white space" - tabs and spaces - with the contempt it deserves,
i.e., it's ignored. Because of this, you can structure your Perl code to
convey the idea of what it is you're doing. Just to give one quick example:
<p><tt>@boats = ("Aloa", "Cheoy Lee", "Pearson", "Mason", "Swan", "Westsail",
"S2", "Petersen", "Hereshoff");&nbsp; # List of sailboats</tt>
<p>Here, we've filled an array called `@boats' with sailboats. OK, that
works - but it could be more understandable:
<p><tt>@array = ("Aloa",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # French OSTAR/IOR
boat</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Cheoy Lee",&nbsp;&nbsp;
# Comfortable but expensive</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Pearson",&nbsp;&nbsp;&nbsp;&nbsp;
# Strong but rather heavy</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Mason",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Well designed, but a bit of a pig</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Swan",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Classy boat - if you've got the money</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Westsail",&nbsp;&nbsp;&nbsp;
# Wetsnails are OK, for double-enders</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "S2",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Nice bay boats - not for offshore use</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Petersen",&nbsp;&nbsp;&nbsp;
# Steel world cruiser, roomy but slow</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Hereshoff");&nbsp;
# Fast and gorgeous; cramped and expensive</tt>
<p>These habits apply to more than just Perl. Most modern languages allow
additional whitespace in order to make the code human-readable. As I go
through this series, I'll do my best to demonstrate at least my own version
of good coding style; I'd like to encourage everyone to make it a consideration
in writing their own code.
<br>&nbsp;
<p><b>Variables</b>
<p>In Perl, the focus is "ease of use". It is a so-called "loosely-typed"
language, where the variable definitions are not rigidly forced into straightjackets;
in fact, there's no way to define a variable that will <b>only</b> hold
a positive 32-bit floating point number.
<p>The three types of variables in Perl are <u>scalars</u>, <u>arrays</u>,
and <u>hashes</u>. Despite the scary names, they're all rather simple:
just variables that contain different arrangements of data.
<p><b>scalars</b> - numbers, strings, or references
<br>A scalar variable is denoted by a `$' sign, i.e. <tt>$num, $joe, $pointer</tt>
<br>Examples:
<br><tt>"0.0421", "Joe's glove", memory location "0xA000"</tt>
<p><b>arrays</b> - sequentially-numbered lists of scalars
<br>An array variable is denoted by an `@' sign, i.e. <tt>@v, @list, @variable</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Example:
<br><tt>&nbsp;&nbsp; 0 - "Sunday"</tt>
<br><tt>&nbsp;&nbsp; 1 - "Monday"</tt>
<br><tt>&nbsp;&nbsp; 2 - "Tuesday"</tt>
<br><tt>&nbsp;&nbsp; 3 - "Wednesday"</tt>
<br><tt>&nbsp;&nbsp; ...</tt>
<p><b>hashes</b> - key-referenced lists of scalars
<br>Hashes are denoted by '%', i.e. <tt>%people, %x, %this_is_a_hash</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Example:
<br><tt>&nbsp;&nbsp; resident - "Sherlock Holmes"</tt>
<br><tt>&nbsp;&nbsp; addr&nbsp;&nbsp;&nbsp;&nbsp; - "221B Baker Street"</tt>
<br><tt>&nbsp;&nbsp; code&nbsp;&nbsp;&nbsp;&nbsp; - "NW1"</tt>
<br><tt>&nbsp;&nbsp; city&nbsp;&nbsp;&nbsp;&nbsp; - "London"</tt>
<br><tt>&nbsp;&nbsp; country&nbsp; - "GB"</tt>
<br><tt>&nbsp;&nbsp; job&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "sleuth"</tt>
<br><tt>&nbsp;&nbsp; ...</tt>
<p>Note that, while arrays are stored in numerical order, hashes are not
- retrieving the first element of a hash will often have nothing to do
with the first element you loaded into it. Hash elements are referred to
by their keys, not their position in the structure.
<p>Within these three data types, you can contain (or point to) anything
you want - and access it easily.
<p>Another important note: $a, @a, and %a are completely unrelated to each
other. They are in different <u>name spaces</u>. I am careful not to use
visually conflicting names like these in my programs, especially since
things like
<tt>$a[0]</tt> (a reference to the 1st element of the @a array)
exist - but this is something you should be aware of.
<br>&nbsp;
<p>Given that variables can contain different types of data - numeric and
string - we're going to need operators that work for both types. Perl provides
these, and you should remember which type goes with what:
<p><tt>&nbsp;&nbsp; Operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Num&nbsp;&nbsp;&nbsp;&nbsp; Str</tt>
<br><tt>&nbsp;&nbsp; --------------------------------------</tt>
<br><tt>&nbsp;&nbsp; Equal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eq</tt>
<br><tt>&nbsp;&nbsp; Not equal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
!=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ne</tt>
<br><tt>&nbsp;&nbsp; Less than&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lt</tt>
<br><tt>&nbsp;&nbsp; Greater than&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gt</tt>
<br><tt>&nbsp;&nbsp; Less than or equal to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; le</tt>
<br><tt>&nbsp;&nbsp; Greater than or equal to&nbsp;&nbsp; >=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ge</tt>
<p>Easy mnemonic - when comparing letters (strings), use letters.
<p>Since I like to give concrete examples, here's a way to give yourself
gray hair and a nervous breakdown:
<br>

<br><tt>#!/usr/bin/perl</tt>
<br><tt># A political evaluation script</tt>
<p><tt>$a = "Al";</tt>
<br><tt>$b = "George";</tt>
<p><tt>if ( $a > $b)&nbsp;&nbsp; { print "$a would make a better President.\n";
}</tt>
<br><tt>if ( $a &lt; $b)&nbsp;&nbsp; { print "$b would make a better President.\n";
}</tt>
<br><tt>if ( $a == $b)&nbsp; { print "$a or $b, there's no difference...\n";
}</tt>
<br>

<p>Hm. The output says that there's no difference. This may reflect political
reality, but what about our comparisons?... oh yeah. We should have used
string operators, huh?
<p>

<br><tt>#!/usr/bin/perl</tt>
<br><tt># A political evaluation script</tt>
<p><tt>$a = "Al";</tt>
<br><tt>$b = "George";</tt>
<p><tt>if ( $a gt $b)&nbsp;&nbsp; { print "$a would make a better President.\n";
}</tt>
<br><tt>if ( $a lt $b)&nbsp;&nbsp; { print "$b would make a better President.\n";
}</tt>
<br><tt>if ( $a eq $b)&nbsp;&nbsp; { print "$a or $b, there's no difference...\n";
}</tt>
<br>

<p><u>Now</u> the comparison operators work properly (and the real-world
logic is backwards... but I digress.)
<p>By the way - why is it that Perl decided that "Al" was the same as "George"
in the first example? Since when do programs have political opinions?
<p>The reason is actually an important one - it has to do with the way
that Perl separates "true" from "false". Given that all of our tests -
"if", "while", "until", etc. depend on that distinction, we need to understand
it.
<p><b>"0" is false, whether it is a number or a string.</b>
<br><b>All undefined variables (those that have not had a value assigned
to them) are false.</b>
<br><b>An empty string - "" or '' - is false.</b>
<br><b>Everything else is true.</b>
<p>All right, here's some tricky stuff - look at these values and decide
whether they're true or false:
<p><tt>"00"&nbsp;&nbsp;&nbsp; "-1"&nbsp;&nbsp;&nbsp; " "&nbsp;&nbsp;&nbsp;
"5 - 5"</tt>
<p>See note <a href="#1">[1]</a> at the end of this article for the answers.
<br>&nbsp;
<p>Another issue that is important is variable interpolation, which is
a way of determining whether something in quotes gets interpreted or not.
Here's an example:
<p><tt>$name =&nbsp; 'Bessie';</tt>
<br><tt>print&nbsp;&nbsp;&nbsp; 'Our cow is named $name.';</tt>
<p>Oops. The output reads
<p><tt>Our cow is named $name.</tt>
<p>I don't think any self-respecting cow would come if called something
like that (I won't even mention the difficulty of pronouncing it.) So,
how do we get Bessie to come to us?
<p><tt># Note the double quotes where the singles used to be!</tt>
<br><tt>$name =&nbsp; 'Bessie';</tt>
<br><tt>print&nbsp;&nbsp;&nbsp; "Our cow is named $name.";</tt>
<p>Successful animal husbandry (and those of you thinking dirty thoughts,
<b>stop
it</b>) via Perl. I <u>told</u> you you could do anything.
<p>What if we wanted to print the variable name? Perl makes that easy,
too.
<p><tt>$joe =&nbsp;&nbsp; "Joe";</tt>
<br><tt>print&nbsp;&nbsp;&nbsp; "The variable \$joe contains the value
$joe.";</tt>
<p>We can print any <u>metacharacter</u>, that is, characters that have
a special meaning in Perl, by <u>escaping</u> them - that is, preceding
them with a backslash. Take a look at this:
<p><tt>$joe =&nbsp;&nbsp; "Joe";</tt>
<br><tt>print&nbsp;&nbsp;&nbsp; "The variable \"\$joe\" contains the value
\"$joe.\"";</tt>
<p>Uh... TMTOWDI:
<p><tt>print&nbsp;&nbsp;&nbsp; 'The variable "$joe" contains the value
"', $joe, '".';</tt>
<p>Take your pick; just be sure you understand the difference. Note that
separate values in the "print" statement take a comma as a separator -
without one, it has a completely different meaning, which we'll discuss
in a future article.
<p>Before we wrap this up, one important consideration: when creating your
script file, always use the "-w" parameter as part of your hash-bang -
<p><tt>#! /usr/bin/perl -w</tt>
<p>This will generate warnings and tell you where the problems are in your
script. Be sure to use it if you're a Perl beginner... and be <u>doubly</u>
sure to use it if you're a Perl expert. The errors don't go away as you
progress; they just grow smarter. :)
<br>&nbsp;
<p><b>Wrap-up</b>
<p>This time around, we took a bit of a journey, skipping lightly over
the rocks and shoals of a simple intro. Next month, we'll get a little
deeper into it; perhaps explore arrays and hashes, and maybe dive head-first
into the incredibly powerful "regular expressions", or regexes of Perl.
My suggestion, meanwhile, is to try a few of the things we've talked about,
maybe do a little experimentation on your own - I've found that the best
way to learn a language is to hack until I hit the limits of my knowledge,
then bring my frustrations to someone who knows more than I do. You can't
get any good answers if you don't even know the questions.
<p>Happy Perl hacking!
<br>&nbsp;
<p>Ben Okopnik
<br><tt><font size=-1>perl -we '$@="\145\143\150\157\040\042\112\165\163\164\040\141\156".</font></tt>
<br><tt><font size=-1>"\157\164\150\145\162\040\120\145\162\154\040\110\141\143\153\145\162".</font></tt>
<br><tt><font size=-1>"\042\040\076\040\057\144\145\166\057\164\164\171";`$@`'</font></tt>
<br>

<br><a NAME="1"></a><b>Note [1]</b>: All true. None of them fit the "false"
categories: "00" is <u>not</u> the same as "0"; neither is "-1". A space,
" ", is not the same as an empty string (""), and "5 - 5", unless <u>evaluated</u>,
is not "0".
<p>References: "Perl: The Complete Reference", Martin C. Brown
<p>Relevant Perl man pages (available on any pro-Perl-y configured system):
<p><tt><font size=-1>perl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - overview&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
perlfaq&nbsp;&nbsp; - frequently asked questions</font></tt>
<br><tt><font size=-1>perltoc&nbsp;&nbsp; - doc TOC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
perldata&nbsp; - data structures</font></tt>
<br><tt><font size=-1>perlsyn&nbsp;&nbsp; - syntax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
perlop&nbsp;&nbsp;&nbsp; - operators and precedence</font></tt>
<br><tt><font size=-1>perlrun&nbsp;&nbsp; - execution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
perlfunc&nbsp; - builtin functions</font></tt>
<br><tt><font size=-1>perltrap&nbsp; - traps for the unwary&nbsp;&nbsp;
perlstyle - style guide</font></tt>
<p><tt><font size=-1>"perldoc" and "perldoc -f"</font></tt>




<!-- *** BEGIN copyright *** -->
<P> <hr> <!-- P --> 
<H5 ALIGN=center>

Copyright &copy; 2000, Ben Okopnik.<BR>
Copying license <A HREF="../copying.html">http://www.linuxgazette.net/copying.html</A><BR> 
Published in Issue 61 of <i>Linux Gazette</i>, January 2001</H5>
<!-- *** END copyright *** -->

<!--startcut ==========================================================-->
<HR><P>
<CENTER>
<!-- *** BEGIN navbar *** -->
<IMG ALT="" SRC="../gx/navbar/left.jpg" WIDTH="14" HEIGHT="45" BORDER="0" ALIGN="bottom"><A HREF="nielsen2.html"><IMG ALT="[ Prev ]" SRC="../gx/navbar/prev.jpg" WIDTH="16" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="index.html"><IMG ALT="[ Table of Contents ]" SRC="../gx/navbar/toc.jpg" WIDTH="220" HEIGHT="45" BORDER="0" ALIGN="bottom" ></A><A HREF="../index.html"><IMG ALT="[ Front Page ]" SRC="../gx/navbar/frontpage.jpg" WIDTH="137" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><IMG ALT="[ Talkback ]" SRC="../gx/navbar/talkback.jpg" WIDTH="121" HEIGHT="45" BORDER="0" ALIGN="bottom"  ><A HREF="../faq/index.html"><IMG ALT="[ FAQ ]" SRC="./../gx/navbar/faq.jpg"WIDTH="62" HEIGHT="45" BORDER="0" ALIGN="bottom"></A><A HREF="padala.html"><IMG ALT="[ Next ]" SRC="../gx/navbar/next.jpg" WIDTH="15" HEIGHT="45" BORDER="0" ALIGN="bottom"  ></A><IMG ALT="" SRC="../gx/navbar/right.jpg" WIDTH="15" HEIGHT="45" ALIGN="bottom">
<!-- *** END navbar *** -->
</CENTER>
</BODY></HTML>
<!--endcut ============================================================-->
