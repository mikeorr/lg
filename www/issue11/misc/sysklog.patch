
From greg@wind.rmcc.com Mon Sep  9 15:50:23 1996
Date: Mon, 09 Sep 1996 07:14:37 -0500 (CDT)
From: "G.W. Wettstein" <greg@wind.rmcc.com>
To: "John M. Fisk" <fiskjm@ctrvax.Vanderbilt.Edu>
Subject: Re: sysklogd fix/patch

On Sep 7,  2:11pm, "John M. Fisk" wrote:
} Subject: sysklogd fix/patch

> Greg,

Good morning John, thanks for the ntoe.

> Sorry to bother you but I've been unsuccessful finding an answer to a
> problem I've been having (and apparently quite a few others as well) with
> syslogd and Slackware '96.
> 
> I just read a post to comp.os.linux.setup that stated that the sysklogd
> devel team had issued an updated version or patch that corrected a problem
> with syslogd which caused it to dump core -- the problem having something
> to do with the networking setup used by Slackware.
> 
> Could you point me to where I could FTP the updated sources or pick up a
> patch for the current sources?

Even better the fixes are enclosed below... :-)

The following set of patches are what I just announced last Friday.
Give them a try and let me know if the problems are fixed.

> Thanks so much!
> 
> Best Wishes,

No problem, hopefully they will make things better.  Have a pleasant
remainder of the week.

> ____________________________________________________________John M. Fisk

Greg

Cut here to begin separating patch 1. -------------------------------------
diff -u --new-file --recursive v1.3/sysklogd-1.3/Makefile sysklogd-1.3/Makefile
--- v1.3/sysklogd-1.3/Makefile	Mon Feb 19 15:18:23 1996
+++ sysklogd-1.3/Makefile	Sun Mar 31 06:11:04 1996
@@ -3,11 +3,10 @@
 CC= gcc
 #CFLAGS= -g -DSYSV -Wall
 #LDFLAGS= -g
-CFLAGS= -O6 -DSYSV -fomit-frame-pointer -Wall
-LDFLAGS= -s -N
+CFLAGS= -O2 -DSYSV -fomit-frame-pointer -Wall -fno-strength-reduce
+LDFLAGS= -s
 
-# Look where your install program is
-#
+# Look where your install program is.
 INSTALL = /usr/bin/install
 BINDIR = /usr/sbin
 MANDIR = /usr/man
@@ -17,6 +16,13 @@
 # to try uncommenting the following define.
 # LIBS = /usr/lib/libresolv.a
 
+# A patch was forwarded which provided support for sysklogd under
+# the ALPHA.  This patch included a reference to a library which may be
+# specific to the ALPHA.  If you are attempting to build this package under
+# an ALPHA and linking fails with unresolved references please try
+# uncommenting the following define.
+# LIBS = ${LIBS} -linux
+
 # Define the following to impart start-up delay in klogd.  This is
 # useful if klogd is started simultaneously or in close-proximity to syslogd.
 # KLOGD_START_DELAY = -DKLOGD_DELAY=5
@@ -54,7 +60,7 @@
 	${CC} ${LDFLAGS} -o syslogd syslogd.o pidfile.o ${LIBS}
 
 klogd:	klogd.o syslog.o pidfile.o ksym.o
-	${CC} ${LDFLAGS} -o klogd klogd.o syslog.o pidfile.o ksym.o
+	${CC} ${LDFLAGS} -o klogd klogd.o syslog.o pidfile.o ksym.o ${LIBS}
 
 syslog_tst: syslog_tst.o
 	${CC} ${LDFLAGS} -o syslog_tst syslog_tst.o
@@ -75,17 +81,17 @@
 	${CC} ${CFLAGS} -c syslog_tst.c
 
 clean:
-	rm -f *.o *.log *~ *.orig;
+	rm -f *.o *.log *~ *.orig
 
 clobber: clean
-	rm -f syslogd klogd syslog_tst TAGS;
+	rm -f syslogd klogd syslog_tst TAGS
 
 install_exec: syslogd klogd
-	${INSTALL} -m 500 -s syslogd ${BINDIR}/syslogd;
-	${INSTALL} -m 500 -s klogd ${BINDIR}/klogd;
+	${INSTALL} -m 500 -s syslogd ${BINDIR}/syslogd
+	${INSTALL} -m 500 -s klogd ${BINDIR}/klogd
 
 install_man:
 	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 sysklogd.8 ${MANDIR}/man8/sysklogd.8
 	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 syslogd.8 ${MANDIR}/man8/syslogd.8
 	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 syslog.conf.5 ${MANDIR}/man5/syslog.conf.5
-	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 klogd.8 ${MANDIR}/MAN8/klogd.8
+	${INSTALL} -o ${MAN_OWNER} -g ${MAN_OWNER} -m 644 klogd.8 ${MANDIR}/man8/klogd.8
diff -u --new-file --recursive v1.3/sysklogd-1.3/NEWS sysklogd-1.3/NEWS
--- v1.3/sysklogd-1.3/NEWS	Fri Dec 15 15:06:25 1995
+++ sysklogd-1.3/NEWS	Sun Mar 31 06:21:14 1996
@@ -1,3 +1,35 @@
+Version 1.3 Patch Level 1
+
+General. ------------------------------------------------------------------
+Cleanups in the Makefile.
+
+Patches to support compilation in the ALPHA environment.  I have not
+been able to test these personally so if anyone has any feedback I
+would be interested in hearing from the Linux ALPHA community.
+
+Spelling and grammar corrections in the man pages.
+
+
+syslogd ------------------------------------------------------------------
+Patch to fix parsing of hostnames in syslogd.c.
+
+The return value of gethostbyname is now properly checked.  This should
+fix the problems with core dumps when name resolution failed.
+
+Bounds error fixed when setting the file descriptors for UNIX domain
+sockets.
+
+
+klogd ---------------------------------------------------------------------
+Error checking and reporting enhanced.  I have a couple of reports
+that klogd is experiencing errors when reading the /proc filesystem.
+Any additional information would be appreciated.
+
+The sys_syslog function has been renamed to ksyslog.  This was in a
+set patches for ALPHA support so I am assuming that this is necessary
+for that environment
+
+
 Version 1.3 
 
 Numerous changes, performance enhancements, code cleanups and bug fixes.
diff -u --new-file --recursive v1.3/sysklogd-1.3/klogd.c sysklogd-1.3/klogd.c
--- v1.3/sysklogd-1.3/klogd.c	Sat Feb 17 14:02:54 1996
+++ sysklogd-1.3/klogd.c	Tue Mar 19 11:50:43 1996
@@ -159,8 +159,10 @@
 
 #define __LIBRARY__
 #include <linux/unistd.h>
-#define __NR_sys_syslog __NR_syslog
-_syscall3(int,sys_syslog,int, type, char *, buf, int, len);
+#ifndef __alpha__
+# define __NR_ksyslog __NR_syslog
+_syscall3(int,ksyslog,int, type, char *, buf, int, len);
+#endif
 
 #define LOG_BUFFER_SIZE 4096
 #define LOG_LINE_LENGTH 1024
@@ -191,7 +193,7 @@
 
 
 /* Function prototypes. */
-extern int sys_syslog(int type, char *buf, int len);
+extern int ksyslog(int type, char *buf, int len);
 static void CloseLogSrc(void);
 extern void restart(int sig);
 extern void stop_logging(int sig);
@@ -209,14 +211,14 @@
 
 {
 	/* Turn on logging of messages to console. */
-  	sys_syslog(7, NULL, 0);
+  	ksyslog(7, NULL, 0);
   
         /* Shutdown the log sources. */
 	switch ( logsrc )
 	{
 	    case kernel:
-		sys_syslog(0, 0, 0);
-		Syslog(LOG_INFO, "Kernel logging (sys_syslog) stopped.");
+		ksyslog(0, 0, 0);
+		Syslog(LOG_INFO, "Kernel logging (ksyslog) stopped.");
 		break;
             case proc:
 		close(kmsg);
@@ -326,7 +328,7 @@
 
 
 	/* Set level of kernel console messaging.. */
-	if ( (sys_syslog(8, NULL, console_log_level) < 0) && \
+	if ( (ksyslog(8, NULL, console_log_level) < 0) && \
 	     (errno == EINVAL) )
 	{
 		/*
@@ -337,7 +339,7 @@
 		 */
 		Syslog(LOG_WARNING, "Cannot set console log level - disabling "
 			      "console output.");
-		sys_syslog(6, NULL, 0);
+		ksyslog(6, NULL, 0);
 	}
 	
 
@@ -349,16 +351,17 @@
 	    ((stat(_PATH_KLOG, &sb) < 0) && (errno == ENOENT)) )
 	{
 	  	/* Initialize kernel logging. */
-	  	sys_syslog(1, NULL, 0);
-		Syslog(LOG_INFO, "klogd %s-%s, log source = sys_syslog "
+	  	ksyslog(1, NULL, 0);
+		Syslog(LOG_INFO, "klogd %s-%s, log source = ksyslog "
 		       "started.", VERSION, PATCHLEVEL);
 		return(kernel);
 	}
 	
 	if ( (kmsg = open(_PATH_KLOG, O_RDONLY)) < 0 )
 	{
-		fputs("klogd: Cannot open proc file system.", stderr);
-		sys_syslog(7, NULL, 0);
+		fprintf(stderr, "klogd: Cannot open proc file system, " \
+			"%d - %s.\n", errno, strerror(errno));
+		ksyslog(7, NULL, 0);
 		exit(1);
 	}
 
@@ -517,12 +520,12 @@
 	 * messages into this fresh buffer.
 	 */
 	memset(log_buffer, '\0', sizeof(log_buffer));
-	if ( (rdcnt = sys_syslog(2, log_buffer, sizeof(log_buffer))) < 0 )
+	if ( (rdcnt = ksyslog(2, log_buffer, sizeof(log_buffer))) < 0 )
 	{
 		if ( errno == EINTR )
 			return;
-		fprintf(stderr, "Error return from sys_sycall: %d - %s\n", \
-			errno, strerror(errno));
+		fprintf(stderr, "klogd: Error return from sys_sycall: " \
+			"%d - %s\n", errno, strerror(errno));
 	}
 	
 	LogLine(log_buffer, rdcnt);
@@ -546,7 +549,8 @@
 	{
 		if ( errno == EINTR )
 			return;
-		Syslog(LOG_ERR, "Cannot read proc file system.");
+		Syslog(LOG_ERR, "Cannot read proc file system: %d - %s.", \
+		       errno, strerror(errno));
 	}
 	
 	LogLine(log_buffer, rdcnt);
@@ -687,8 +691,8 @@
 			output_file = stdout;
 		else if ( (output_file = fopen(output, "w")) == (FILE *) 0 )
 		{
-			fprintf(stderr, "klogd: Cannot open output file %s - "\
-				"%s\n", output, strerror(errno));
+			fprintf(stderr, "klogd: Cannot open output file " \
+				"%s - %s\n", output, strerror(errno));
 			return(1);
 		}
 	}
diff -u --new-file --recursive v1.3/sysklogd-1.3/sysklogd.8 sysklogd-1.3/sysklogd.8
--- v1.3/sysklogd-1.3/sysklogd.8	Sat Feb 17 14:02:54 1996
+++ sysklogd-1.3/sysklogd.8	Tue Mar  5 12:52:59 1996
@@ -39,7 +39,7 @@
 .BR syslogd (8)
 derived from the
 stock BSD sources.  Support for kernel logging is provided by the
-.BR syslogd (8)
+.BR klogd (8)
 utility which allows kernel logging to be conducted in either a
 standalone fashion or as a client of syslogd.
 
@@ -91,7 +91,7 @@
 .TP
 .BI "\-l " "hostlist"
 Specify a hostname that should be logged only with its simple hostname
-and not the the fqdn. Multiple hosts may be specified using the colon
+and not the fqdn. Multiple hosts may be specified using the colon
 (``:'') separator.
 .TP
 .BI "\-m " "interval"
@@ -195,8 +195,8 @@
 .PP
 Under the new scheme this behavior remains the same.  The difference
 is the addition of four new specifiers, the asterisk (\fB*\fR)
-wildcard the equation sign (\fB=\fR), the exclamation mark
-(\fB!\fR) and the minus sign (\fB-\fR).
+wildcard, the equation sign (\fB=\fR), the exclamation mark
+(\fB!\fR), and the minus sign (\fB-\fR).
 
 The \fB*\fR specifies that all messages for the
 specified facility are to be directed to the destination.  Note that
@@ -215,7 +215,7 @@
 .IP
 .nf
 	# Sample syslog.conf
-	daemon.=debug			/usr/adm/debug
+	*.=debug			/usr/adm/debug
 .fi
 .PP
 .\" The \fB!\fR as the first character of a priority inverts the above
@@ -456,11 +456,11 @@
 .SH DEBUGGING
 When debugging is turned on using
 .B "\-d"
-option the
+option then
 .B syslogd
-will very verbose by writing much of what it does on stdout. Whenever
+will be very verbose by writing much of what it does on stdout. Whenever
 the configuration file is reread and re-parsed you'll see a tabular,
-corresponding on the internal data structure. This tabular consists of
+corresponding to the internal data structure. This tabular consists of
 four fields:
 .TP
 .I number
@@ -489,7 +489,7 @@
 This field shows additional arguments to the actions in the last
 field. For file-logging this is the filename for the logfile; for
 user-logging this is a list of users; for remote logging this is the
-the hostname of the machine to log to; for console-logging this is the
+hostname of the machine to log to; for console-logging this is the
 used console; for tty-logging this is the specified tty; wall has no
 additional arguments.
 .SH FILES
diff -u --new-file --recursive v1.3/sysklogd-1.3/syslogd.c sysklogd-1.3/syslogd.c
--- v1.3/sysklogd-1.3/syslogd.c	Mon Feb 19 09:24:33 1996
+++ sysklogd-1.3/syslogd.c	Fri Mar  8 11:19:25 1996
@@ -715,9 +715,15 @@
 		 * should return the simple hostname or the fqdn. A
 		 * good piece of software should be aware of both and
 		 * we want to distribute good software.  Joey
+		 *
+		 * Good software also always checks its return values...
+		 * If syslogd starts up before DNS is up & /etc/hosts
+		 * doesn't have LocalHostName listed, gethostbyname will
+		 * return NULL. 
 		 */
 		hent = gethostbyname(LocalHostName);
-		sprintf(LocalHostName, "%s", hent->h_name);
+		if ( hent )
+			sprintf(LocalHostName, "%s", hent->h_name);
 		if ( (p = index(LocalHostName, '.')) )
 		{
 			*p++ = '\0';
@@ -890,7 +896,7 @@
 					dprintf("%d ", nfds);
 			dprintf("\n");
 		}
-		for (fd= 0; fd <= FD_SETSIZE; ++fd)
+		for (fd= 0; fd < FD_SETSIZE; ++fd)
 		  if ( FD_ISSET(fd, &readfds) && FD_ISSET(fd, &unixm) ) {
 			dprintf("Message from UNIX socket #%d.\n", fd);
 			memset(line, '\0', sizeof(line));
@@ -979,9 +985,8 @@
 crunch_list(list)
 	char *list;
 {
-	int count;
-	int i;
-	char *p;
+	int count, i;
+	char *p, *q;
 	char **result = NULL;
 
 	p = list;
@@ -1012,15 +1017,15 @@
 	 * so we don't have to care about this.
 	 */
 	count = 0;
-	while ((i=(int)index(p, LIST_DELIMITER))) {
-		if ((result[count] = \
-		     (char *)malloc(sizeof(char) * i - (int)p +1)) == NULL) {
+	while ((q=index(p, LIST_DELIMITER))) {
+		result[count] = (char *) malloc((q - p + 1) * sizeof(char));
+		if (result[count] == NULL) {
 			printf ("Sorry, can't get enough memory, exiting.\n");
 			exit(0);
 		}
-		strncpy(result[count],p, i - (int)p);
-		result[count][i - (int)p] = '\0';
-		p = (char *)i;p++;
+		strncpy(result[count], p, q - p);
+		result[count][q - p] = '\0';
+		p = q; p++;
 		count++;
 	}
 	if ((result[count] = \
diff -u --new-file --recursive v1.3/sysklogd-1.3/version.h sysklogd-1.3/version.h
--- v1.3/sysklogd-1.3/version.h	Tue Feb 27 15:48:42 1996
+++ sysklogd-1.3/version.h	Sun Mar 31 05:58:48 1996
@@ -1,2 +1,2 @@
 #define VERSION "1.3"
-#define PATCHLEVEL "0"
+#define PATCHLEVEL "1"
Cut here to complete separating patch 1. ----------------------------------

Cut here to begin separating patch 2. -------------------------------------
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/MANIFEST sysklogd-1.3/MANIFEST
--- v1.3-1/sysklogd-1.3/MANIFEST	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/MANIFEST	Thu May  2 15:21:49 1996
@@ -17,6 +17,9 @@
 ksym.c:		Source module for the kernel log daemon which implements
 		kernel numeric address to symbol translations.
 
+ksym_mod.c:	Source module which contains functions which allow ksym.c
+		to resolve symbols found in loadable kernel modules.	
+
 syslogd.c:	Source code for the system log daemon.
 
 syslog.c:	A slightly modified version of the syslog.c file found in
@@ -46,3 +49,10 @@
 
 kernel.patch:	A source code patch which modifies the linux kernel to
 		delimit addresses for symbolic translation by klogd.
+
+oops.c:		C source for a loadable kernel module which can be used
+		to generate a kernel protection fault.  This is used to
+		test the address resolution capabilities of klogd.
+
+oops_test.c:	A small driver program used in conjunction with the oops
+		module to generate a kernel protection fault.
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/Makefile sysklogd-1.3/Makefile
--- v1.3-1/sysklogd-1.3/Makefile	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/Makefile	Thu May  2 15:19:07 1996
@@ -52,15 +52,18 @@
 .c.o:
 	${CC} ${CFLAGS} -c $*.c
 
-all:	syslogd	klogd syslog_tst
+all: syslogd klogd
+
+test: syslog_tst ksym oops_test
 
 install: install_man install_exec
 
 syslogd: syslogd.o pidfile.o
 	${CC} ${LDFLAGS} -o syslogd syslogd.o pidfile.o ${LIBS}
 
-klogd:	klogd.o syslog.o pidfile.o ksym.o
-	${CC} ${LDFLAGS} -o klogd klogd.o syslog.o pidfile.o ksym.o ${LIBS}
+klogd:	klogd.o syslog.o pidfile.o ksym.o ksym_mod.o
+	${CC} ${LDFLAGS} -o klogd klogd.o syslog.o pidfile.o ksym.o \
+		ksym_mod.o ${LIBS}
 
 syslog_tst: syslog_tst.o
 	${CC} ${LDFLAGS} -o syslog_tst syslog_tst.o
@@ -77,14 +80,29 @@
 ksym.o: ksym.c klogd.h
 	${CC} ${CFLAGS} ${KLOGD_FLAGS} -c ksym.c
 
+ksym_mod.o: ksym_mod.c klogd.h
+	${CC} ${CFLAGS} ${KLOGD_FLAGS} -c ksym_mod.c
+
 syslog_tst.o: syslog_tst.c
 	${CC} ${CFLAGS} -c syslog_tst.c
 
+oops_test: oops.o
+	${CC} ${CFLAGS} -o oops_test oops_test.c
+
+oops.o: oops.c
+	${CC} ${CFLAGS} -D__KERNEL__ -DMODULE -c oops.c
+
+ksym: ksym_test.o ksym_mod.o
+	${CC} ${LDFLAGS} -o ksym ksym_test.o ksym_mod.o
+
+ksym_test.o: ksym.c
+	${CC} ${CFLAGS} -DTEST -o ksym_test.o -c ksym.c
+
 clean:
 	rm -f *.o *.log *~ *.orig
 
 clobber: clean
-	rm -f syslogd klogd syslog_tst TAGS
+	rm -f syslogd klogd ksym syslog_tst oops_test TAGS
 
 install_exec: syslogd klogd
 	${INSTALL} -m 500 -s syslogd ${BINDIR}/syslogd
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/klogd.c sysklogd-1.3/klogd.c
--- v1.3-1/sysklogd-1.3/klogd.c	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/klogd.c	Wed Apr 17 13:42:58 1996
@@ -380,7 +380,7 @@
 	{
 		fputs("Logging line:\n", stderr);
 		fprintf(stderr, "\tLine: %s\n", fmt);
-		fprintf(stderr, "\tPriority: %c\n", *(fmt+1));
+		fprintf(stderr, "\tPriority: %d\n", priority);
 	}
 
 	/* Handle output to a file. */
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/klogd.h sysklogd-1.3/klogd.h
--- v1.3-1/sysklogd-1.3/klogd.h	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/klogd.h	Sun Mar 31 14:24:42 1996
@@ -13,5 +13,6 @@
 
 /* Function prototypes. */
 extern int InitKsyms(char *);
+extern int InitMsyms(void);
 extern char * ExpandKadds(char *, char *);
 extern void Syslog(int priority, char *fmt, ...);
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/ksym.c sysklogd-1.3/ksym.c
--- v1.3-1/sysklogd-1.3/ksym.c	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/ksym.c	Wed May  1 16:24:54 1996
@@ -1,6 +1,7 @@
 /*
     ksym.c - functions for kernel address->symbol translation
-    Copyright (c) 1995  Dr. G.W. Wettstein <greg@wind.rmcc.com>
+    Copyright (c) 1995, 1996  Dr. G.W. Wettstein <greg@wind.rmcc.com>
+    Copyright (c) 1996 Enjellic Systems Development
 
     This file is part of the sysklogd package, a kernel and system log daemon.
 
@@ -69,27 +70,20 @@
 #include <malloc.h>
 #include <sys/utsname.h>
 #include "klogd.h"
+#include "ksyms.h"
 
 #define VERBOSE_DEBUGGING 0
 
 
-/* Variables, structures and type definitions static to this module. */
+/* Variables static to this module. */
 struct sym_table
 {
 	unsigned long value;
 	char *name;
 };
 
-struct symbol
-{
-	char *name;
-	int size;
-	int offset;
-};
-
-static struct sym_table *sym_array = (struct sym_table *) 0;
-
 static int num_syms = 0;
+static struct sym_table *sym_array = (struct sym_table *) 0;
 
 static char *system_maps[] =
 {
@@ -104,7 +98,7 @@
 
 
 #if defined(TEST)
-static int debugging = 1;
+int debugging;
 #else
 extern int debugging;
 #endif
@@ -192,7 +186,7 @@
 	 */
 	while ( !feof(sym_file) )
 	{
-		if ( fscanf(sym_file, "%8lx %c %s\n", &address, &type, sym)
+		if ( fscanf(sym_file, "%lx %c %s\n", &address, &type, sym)
 		    != 3 )
 		{
 			Syslog(LOG_ERR, "Error in symbol table input.");
@@ -303,7 +297,7 @@
 		version = 0;
 		while ( !feof(sym_file) && (version == 0) )
 		{
-			if ( fscanf(sym_file, "%8lx %c %s\n", &address, \
+			if ( fscanf(sym_file, "%lx %c %s\n", &address, \
 				    &type, sym) != 3 )
 			{
 				Syslog(LOG_ERR, "Error in symbol table input.");
@@ -527,7 +521,7 @@
  *		closely matching the address is returned.
  **************************************************************************/
 
-extern char * LookupSymbol(value, sym)
+static char * LookupSymbol(value, sym)
 
 	unsigned long value;
 
@@ -556,6 +550,9 @@
 		last = sym_array[lp].name;
 	}
 
+	if ( (last = LookupModuleSymbol(value, sym)) != (char *) 0 )
+		return(last);
+
 	return((char *) 0);
 }
 
@@ -594,8 +591,29 @@
 	auto int value;
 
 	auto struct symbol sym;
+
+
+	/*
+	 * This is as handy a place to put this as anyplace.
+	 *
+	 * Since the insertion of kernel modules can occur in a somewhat
+	 * dynamic fashion we need some mechanism to insure that the
+	 * kernel symbol tables get read just prior to when they are
+	 * needed.
+	 *
+	 * To accomplish this we look for the Oops string and use its
+	 * presence as a signal to load the module symbols.
+	 *
+	 * This is not the best solution of course, especially if the
+	 * kernel is rapidly going out to lunch.  What really needs to
+	 * be done is to somehow generate a callback from the
+	 * kernel whenever a module is loaded or unloaded.  I am
+	 * open for patches.
+	 */
+	if ( (strstr(line, "Oops:") != (char *) 0) && !InitMsyms() )
+		Syslog(LOG_WARNING, "Cannot load kernel module symbols.\n");
 	
-	
+
 	/*
 	 * Early return if there do not appear to be any kernel
 	 * messages in this line.
@@ -670,21 +688,17 @@
 
 extern int main(int argc, char *argv[])
 {
-	auto long int value;
 	auto char line[1024], eline[2048];
+
+	debugging = 1;
 	
 	
-#if 0
-	value = atol(argv[1]);
-	fprintf(stdout, "Value of %ld: %s\n", value, LookupSymbol(value));
-#endif
-
 	if ( !InitKsyms((char *) 0) )
 	{
 		fputs("ksym: Error loading system map.\n", stderr);
 		return(1);
 	}
-	
+
 	while ( !feof(stdin) )
 	{
 		gets(line);
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/ksym_mod.c sysklogd-1.3/ksym_mod.c
--- v1.3-1/sysklogd-1.3/ksym_mod.c	Wed Dec 31 18:00:00 1969
+++ sysklogd-1.3/ksym_mod.c	Wed May  1 16:15:25 1996
@@ -0,0 +1,587 @@
+/*
+    ksym_mod.c - functions for building symbol lookup tables for klogd
+    Copyright (c) 1995, 1996  Dr. G.W. Wettstein <greg@wind.rmcc.com>
+    Copyright (c) 1996 Enjellic Systems Development
+
+    This file is part of the sysklogd package, a kernel and system log daemon.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+ * This file implements functions which are useful for building
+ * a symbol lookup table based on the in kernel symbol table
+ * maintained by the Linux kernel.
+ *
+ * Proper logging of kernel panics generated by loadable modules
+ * tends to be difficult.  Since the modules are loaded dynamically
+ * their addresses are not known at kernel load time.  A general
+ * protection fault (Oops) cannot be properly deciphered with 
+ * classic methods using the static symbol map produced at link time.
+ *
+ * One solution to this problem is to have klogd attempt to translate
+ * addresses from module when the fault occurs.  By referencing the
+ * the kernel symbol table proper resolution of these symbols is made
+ * possible.
+ *
+ * At least that is the plan.
+ */
+
+
+/* Includes. */
+#include <stdlib.h>
+#include <malloc.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include <sys/fcntl.h>
+#include <sys/stat.h>
+#include <linux/time.h>
+#include <linux/module.h>
+#include <stdarg.h>
+#include <paths.h>
+
+#include "klogd.h"
+#include "ksyms.h"
+
+
+/*
+ * The following bit uses some kernel/library magic to product what
+ * looks like a function call to user level code.  This function is
+ * actually a system call in disguise.  The purpose of the getsyms
+ * call is to return a current copy of the in-kernel symbol table.
+ */
+#define __LIBRARY__
+#include <linux/unistd.h>
+# define __NR_getsyms __NR_get_kernel_syms
+_syscall1(int, getsyms, struct kernel_sym *, syms);
+#undef __LIBRARY__
+extern int getsyms(struct kernel_sym *);
+
+
+/* Variables static to this module. */
+struct sym_table
+{
+	unsigned long value;
+	char *name;
+};
+
+struct Module
+{
+	struct sym_table *sym_array;
+	int num_syms;
+
+	char *name;
+	struct module module;
+};
+
+static int num_modules;
+struct Module *sym_array_modules = (struct Module *) 0;
+
+static int have_modules = 0;
+
+#if defined(TEST)
+static int debugging = 1;
+#else
+extern int debugging;
+#endif
+
+
+/* Function prototypes. */
+static void FreeModules(void);
+static int AddSymbol(struct Module *mp, unsigned long, char *);
+static int AddModule(unsigned long, char *);
+static int symsort(const void *, const void *);
+
+
+/**************************************************************************
+ * Function:	InitMsyms
+ *
+ * Purpose:	This function is responsible for building a symbol
+ *		table which can be used to resolve addresses for
+ *		loadable modules.
+ *
+ * Arguements:	Void
+ *
+ * Return:	A boolean return value is assumed.
+ *
+ *		A false value indicates that something went wrong.
+ *
+ *		True if loading is successful.
+ **************************************************************************/
+
+extern int InitMsyms()
+
+{
+	auto int	rtn,
+			tmp;
+
+	auto struct kernel_sym	*ksym_table,
+				*p;
+
+
+	/* Init the symbol table if one exists. */
+	if ( num_modules > 0 )
+		FreeModules();
+
+
+	/*
+	 * The system call which returns the kernel symbol table has
+	 * essentialy two modes of operation.  Called with a null pointer
+	 * the system call returns the number of symbols defined in the
+	 * the table.
+	 *
+	 * The second mode of operation is to pass a valid pointer to
+	 * the call which will then load the current symbol table into
+	 * the memory provided.
+	 *
+	 * Returning the symbol table is essentially an all or nothing
+	 * proposition so we need to pre-allocate enough memory for the
+	 * complete table regardless of how many symbols we need.
+	 *
+	 * Bummer.
+	 */
+	rtn = getsyms((struct kernel_sym *) 0);
+	if ( debugging )
+		fprintf(stderr, "Loading kernel module symbols - "
+			"Size of table: %d\n", rtn);
+
+	ksym_table = (struct kernel_sym *) malloc(rtn * \
+						  sizeof(struct kernel_sym));
+	if ( ksym_table == (struct kernel_sym *) 0 )
+	{
+		Syslog(LOG_WARNING, " Failed memory allocation for kernel "
+		       "symbol table.\n");
+		return(0);
+	}
+	if ( (rtn = getsyms(ksym_table)) == 0 )
+		Syslog(LOG_WARNING, "Kernel symbol read returned 0\n");
+
+
+	/*
+	 * Build a symbol table compatible with the other one used by
+	 * klogd.
+	 */
+	tmp = rtn;
+	p = ksym_table;
+	while ( tmp-- )
+	{
+ 		if ( !AddModule(p->value, p->name) )
+		{
+			Syslog(LOG_WARNING, "Error adding kernel module table "
+				"entry.\n");
+			free(ksym_table);
+			return(0);
+		}
+		++p;
+	}
+
+	/* Sort the symbol tables in each module. */
+	for (tmp= 0; tmp < num_modules; ++tmp)
+	{
+		if ( sym_array_modules[tmp].num_syms < 2 )
+			continue;
+		qsort(sym_array_modules[tmp].sym_array, \
+		      sym_array_modules[tmp].num_syms, \
+		      sizeof(struct sym_table), symsort);
+	}
+
+	free(ksym_table);
+	return(1);
+}
+
+
+static int symsort(p1, p2)
+
+     const void *p1;
+
+     const void *p2;
+
+{
+	auto const struct sym_table	*sym1 = p1,
+					*sym2 = p2;
+
+	if ( sym1->value < sym2->value )
+		return(-1);
+	if ( sym1->value == sym2->value )
+		return(0);
+	return(1);
+}
+
+
+/**************************************************************************
+ * Function:	FreeModules
+ *
+ * Purpose:	This function is used to free all memory which has been
+ *		allocated for the modules and their symbols.
+ *
+ * Arguements:	None specified.
+ *
+ * Return:	void
+ **************************************************************************/
+
+static void FreeModules()
+
+{
+	auto int	nmods,
+			nsyms;
+
+	auto struct Module *mp;
+
+
+	for (nmods= 0; nmods <num_modules; ++nmods)
+	{
+		mp = &sym_array_modules[nmods];
+		if ( mp->num_syms == 0 )
+			continue;
+	       
+		for (nsyms= 0; nsyms < mp->num_syms; ++nsyms)
+			free(mp->sym_array[nsyms].name);
+		free(mp->sym_array);
+	}
+
+	free(sym_array_modules);
+	sym_array_modules = (struct Module *) 0;
+	have_modules = num_modules = 0;
+	return;
+}
+
+
+/**************************************************************************
+ * Function:	AddModule
+ *
+ * Purpose:	This function is responsible for adding a module to
+ *		the list of currently loaded modules.
+ *
+ * Arguements:	(unsigned long) address, (char *) symbol
+ *
+ *		address:->	The address of the module.
+ *
+ *		symbol:->	The name of the module.
+ *
+ * Return:	int
+ **************************************************************************/
+
+static int AddModule(address, symbol)
+
+     unsigned long address;
+
+     char *symbol;
+
+{
+	auto int memfd;
+
+	auto struct Module *mp;
+
+
+	/* Return if we have loaded the modules. */
+	if ( have_modules )
+		return(1);
+
+	/*
+	 * The following section of code is responsible for determining
+	 * whether or not we are done reading the list of modules.
+	 */
+	if ( symbol[0] == '#' )
+	{
+		if ( symbol[1] == '\0' )
+		{
+			/*
+			 * A symbol which consists of a # sign only
+			 * signifies a a resident kernel segment.  When we
+			 * hit one of these we are done reading the
+			 * module list.
+			 */
+			have_modules = 1;
+			return(1);
+		}
+
+		/* Allocate space for the module. */
+		sym_array_modules = (struct Module *) \
+			realloc(sym_array_modules, \
+				(num_modules+1) * sizeof(struct Module));
+		if ( sym_array_modules == (struct Module *) 0 )
+		{
+			Syslog(LOG_WARNING, "Cannot allocate Module array.\n");
+			return(0);
+		}
+		mp = &sym_array_modules[num_modules];
+
+		if ( (memfd = open("/dev/kmem", O_RDONLY)) < 0 )
+		{
+			Syslog(LOG_WARNING, "Error opening /dev/kmem\n");
+			return(1);
+		}
+		if ( lseek(memfd, address, SEEK_SET) < 0 )
+		{
+			Syslog(LOG_WARNING, "Error seeking in /dev/kmem\n");
+			return(0);
+		}
+		if ( read(memfd, \
+			  (char *)&sym_array_modules[num_modules].module,  \
+			  sizeof(struct module)) < 0 )
+		{
+			Syslog(LOG_WARNING, "Error reading module "
+			       "descriptor.\n");
+			return(0);
+		}
+		close(memfd);
+
+		/* Save the module name. */
+		mp->name = (char *) malloc(strlen(&symbol[1]) + 1);
+		if ( mp->name == (char *) 0 )
+			return(0);
+		strcpy(mp->name, &symbol[1]);
+
+		mp->num_syms = 0;
+		mp->sym_array = (struct sym_table *) 0;
+		++num_modules;
+		return(1);
+	}
+	else
+	{
+		mp = &sym_array_modules[num_modules - 1];
+		AddSymbol(mp, address, symbol);
+	}
+
+
+	return(1);
+}
+
+
+/**************************************************************************
+ * Function:	AddSymbol
+ *
+ * Purpose:	This function is responsible for adding a symbol name
+ *		and its address to the symbol table.
+ *
+ * Arguements:	(struct Module *) mp, (unsigned long) address, (char *) symbol
+ *
+ *		mp:->	A pointer to the module which the symbol is
+ *			to be added to.
+ *
+ *		address:->	The address of the symbol.
+ *
+ *		symbol:->	The name of the symbol.
+ *
+ * Return:	int
+ *
+ *		A boolean value is assumed.  True if the addition is
+ *		successful.  False if not.
+ **************************************************************************/
+
+static int AddSymbol(mp, address, symbol)
+
+	struct Module *mp;     
+
+	unsigned long address;
+	
+	char *symbol;
+	
+{
+	auto int tmp;
+
+
+	/* Allocate space for the symbol table entry. */
+	mp->sym_array = (struct sym_table *) realloc(mp->sym_array, \
+        	(mp->num_syms+1) * sizeof(struct sym_table));
+	if ( mp->sym_array == (struct sym_table *) 0 )
+		return(0);
+
+	/* Then the space for the symbol. */
+	tmp = strlen(symbol);
+	tmp += (strlen(mp->name) + 1);
+	mp->sym_array[mp->num_syms].name = (char *) malloc(tmp + 1);
+	if ( mp->sym_array[mp->num_syms].name == (char *) 0 )
+		return(0);
+	memset(mp->sym_array[mp->num_syms].name, '\0', tmp + 1);
+	
+	/* Stuff interesting information into the module. */
+	mp->sym_array[mp->num_syms].value = address;
+	strcpy(mp->sym_array[mp->num_syms].name, mp->name);
+	strcat(mp->sym_array[mp->num_syms].name, ":");
+	strcat(mp->sym_array[mp->num_syms].name, symbol);
+	++mp->num_syms;
+
+	return(1);
+}
+
+
+/**************************************************************************
+ * Function:	LookupModuleSymbol
+ *
+ * Purpose:	Find the symbol which is related to the given address from
+ *		a kernel module.
+ *
+ * Arguements:	(long int) value, (struct symbol *) sym
+ *
+ *		value:->	The address to be located.
+ * 
+ *		sym:->		A pointer to a structure which will be
+ *				loaded with the symbol's parameters.
+ *
+ * Return:	(char *)
+ *
+ *		If a match cannot be found a diagnostic string is printed.
+ *		If a match is found the pointer to the symbolic name most
+ *		closely matching the address is returned.
+ **************************************************************************/
+
+extern char * LookupModuleSymbol(value, sym)
+
+	unsigned long value;
+
+	struct symbol *sym;
+	
+{
+	auto int	nmod,
+			nsym;
+
+	auto struct sym_table *last;
+
+	auto struct Module *mp;
+
+
+	sym->size = 0;
+	sym->offset = 0;
+	if ( num_modules == 0 )
+		return((char *) 0);
+	
+	for(nmod= 0; nmod < num_modules; ++nmod)
+	{
+		mp = &sym_array_modules[nmod];
+
+		/*
+		 * Run through the list of symbols in this module and
+		 * see if the address can be resolved.
+		 */
+		for(nsym= 1, last = &mp->sym_array[0];
+		    nsym < mp->num_syms;
+		    ++nsym)
+		{
+			if ( mp->sym_array[nsym].value > value )
+			{		
+				sym->offset = value - last->value;
+				sym->size = mp->sym_array[nsym].value - \
+					last->value;
+				return(last->name);
+			}
+			last = &mp->sym_array[nsym];
+		}
+
+
+		/*
+		 * At this stage of the game we still cannot give up the
+		 * ghost.  There is the possibility that the address is
+		 * from a module which has no symbols registered with
+		 * the kernel.  The solution is to compare the address
+		 * against the starting address and extant of the module
+		 * If it is in this range we can at least return the
+		 * name of the module.
+		 */
+		if ( (void *) value >= mp->module.addr &&
+		     (void *) value <= (mp->module.addr + \
+					mp->module.size * 4096) )
+		{
+			/*
+			 * A special case needs to be checked for.  The above
+			 * conditional tells us that we are within the
+			 * extant of this module but symbol lookup has
+			 * failed.
+			 *
+			 * We need to check to see if any symbols have
+			 * been defined in this module.  If there have been
+			 * symbols defined the assumption must be made that
+			 * the faulting address lies somewhere beyond the
+			 * last symbol.  About the only thing we can do
+			 * at this point is use an offset from this
+			 * symbol.
+			 */
+			if ( mp->num_syms > 0 )
+			{
+				last = &mp->sym_array[mp->num_syms - 1];
+				sym->size = (int) mp->module.addr + \
+					(mp->module.size * 4096) - value;
+				sym->offset = value - last->value;
+				return(last->name);
+			}
+
+			/*
+			 * There were no symbols defined for this module.
+			 * Return the module name and the offset of the
+			 * faulting address in the module.
+			 */
+			sym->size = mp->module.size * 4096;
+			sym->offset = (void *) value - mp->module.addr;
+			return(mp->name);
+		}
+	}
+
+	/* It has been a hopeless exercise. */
+	return((char *) 0);
+}
+
+
+/*
+ * Setting the -DTEST define enables the following code fragment to
+ * be compiled.  This produces a small standalone program which will
+ * dump the current kernel symbol table.
+ */
+#if defined(TEST)
+
+#include <stdarg.h>
+
+
+extern int main(int, char **);
+
+
+int main(argc, argv)
+
+	int argc;
+
+	char *argv[];
+
+{
+	auto int lp, syms;
+
+
+	if ( !InitMsyms() )
+	{
+		fprintf(stderr, "Cannot load module symbols.\n");
+		return(1);
+	}
+
+	printf("Number of modules: %d\n\n", num_modules);
+
+	for(lp= 0; lp < num_modules; ++lp)
+	{
+		printf("Module #%d = %s, Number of symbols = %d\n", lp + 1, \
+		       sym_array_modules[lp].name, \
+		       sym_array_modules[lp].num_syms);
+
+		for (syms= 0; syms < sym_array_modules[lp].num_syms; ++syms)
+		{
+			printf("\tSymbol #%d\n", syms + 1);
+			printf("\tName: %s\n", \
+			       sym_array_modules[lp].sym_array[syms].name);
+			printf("\tAddress: %lx\n\n", \
+			       sym_array_modules[lp].sym_array[syms].value);
+		}
+	}
+
+	FreeModules();
+	return(0);
+}
+#endif
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/ksyms.h sysklogd-1.3/ksyms.h
--- v1.3-1/sysklogd-1.3/ksyms.h	Wed Dec 31 18:00:00 1969
+++ sysklogd-1.3/ksyms.h	Sun Mar 31 16:44:26 1996
@@ -0,0 +1,36 @@
+/*
+    ksym.h - Definitions for symbol table utilities.
+    Copyright (c) 1995, 1996  Dr. G.W. Wettstein <greg@wind.rmcc.com>
+    Copyright (c) 1996 Enjellic Systems Development
+
+    This file is part of the sysklogd package, a kernel and system log daemon.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+
+
+/* Variables, structures and type definitions static to this module. */
+
+struct symbol
+{
+	char *name;
+	int size;
+	int offset;
+};
+
+
+/* Function prototypes. */
+extern char * LookupModuleSymbol(unsigned long int, struct symbol *);
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/oops.c sysklogd-1.3/oops.c
--- v1.3-1/sysklogd-1.3/oops.c	Wed Dec 31 18:00:00 1969
+++ sysklogd-1.3/oops.c	Thu May  2 15:25:49 1996
@@ -0,0 +1,118 @@
+/*
+ * Loadable driver which provides the ability to generate a kernel
+ * protection fault.  Mainly useful for testing the address translation
+ * capabilities of klogd.
+ *
+ * Fri Oct 27 14:34:27 CDT 1995:  Dr. Wettstein
+ *
+ *	Initial version.
+ */
+
+#define NEW_MODULES
+
+/* Kernel includes. */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+
+/* Standard module stuff. */
+#if defined(NEW_MODULES)
+#include <linux/module.h>
+#else
+#include <linux/module.h>
+#include <linux/version.h>
+char kernel_version[] = UTS_RELEASE;
+#endif
+
+
+static int major = 32;
+
+
+#ifdef MODULE
+static int oops_ioctl(struct inode *, struct file *, unsigned int cmd, unsigned long arg);
+static int oops_open(struct inode * node, struct file * file);
+static void oops(void);
+
+static struct symbol_table these_symbols = {
+#include <linux/symtab_begin.h>
+	X(oops_open),
+	X(oops_ioctl),
+	X(oops),
+#include <linux/symtab_end.h>
+};
+
+/* driver specific module definitions */
+static struct file_operations oops_fops1 = {
+	NULL,		/* hw_lseek */
+	NULL,		/* hw_read */
+	NULL,		/* write */
+	NULL,		/* hw_readdir */
+	NULL,		/* hw_select */
+	oops_ioctl,	/* hw_ioctl */
+	NULL,		/* mmap */
+	oops_open,	/* hw_open */
+	NULL,		/* hw_release */
+	NULL		/* fsync */
+};
+
+static int oops_open(struct inode * node, struct file * file)
+{
+	printk("Called oops_open.\n");
+	return(0);
+}
+
+
+static int oops_ioctl(struct inode * node, struct file * file, \
+		      unsigned int cmd, unsigned long arg)
+{
+	
+	printk("Called oops_ioctl.\n");
+	printk("Cmd: %d, Arg: %ld\n", cmd, arg);
+	if ( cmd == 1 )
+	{
+		oops();
+	}
+		
+	return(0);
+}
+
+static void oops()
+
+{
+	auto unsigned long *p = (unsigned long *) 828282828;
+	*p = 5;
+	return;
+}
+
+	
+int
+init_module(void)
+{
+	printk("oops: Module initilization.\n");
+	if (register_chrdev(major, "oops", &oops_fops1)) {
+		printk("register_chrdev failed.");
+		return -EIO;
+	}
+
+	printk("oops: Registering symbols.\n");
+  	register_symtab(&these_symbols);
+	
+	return 0;
+}
+
+
+void
+cleanup_module(void)
+{
+	/* driver specific cleanups, ususally "unregister_*()" */
+	printk("oops: Module unloadeding.\n");
+	if (unregister_chrdev(major, "oops") != 0)
+		printk("cleanup_module failed\n");
+	else
+		printk("cleanup_module succeeded\n");
+
+	return;
+
+}
+#endif /* MODULE */
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/oops_test.c sysklogd-1.3/oops_test.c
--- v1.3-1/sysklogd-1.3/oops_test.c	Wed Dec 31 18:00:00 1969
+++ sysklogd-1.3/oops_test.c	Fri Apr 26 13:07:32 1996
@@ -0,0 +1,52 @@
+/*
+ * This is a small test program for generating a kernel protection fault
+ * using the oops loadable module.
+ *
+ * Fri Apr 26 12:52:43 CDT 1996:  Dr. Wettstein
+ *	Initial version.
+ */
+
+
+/* Includes. */
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+
+/* Function prototypes. */
+extern int main(int, char **);
+
+
+extern int main(argc, argv)
+
+     int argc;
+
+     char *argv[];
+
+{
+	auto int fd;
+
+	if ( argc != 2 )
+	{
+		fprintf(stderr, "No oops device specified.\n");
+		return(1);
+	}
+
+	if ( (fd = open(argv[1], O_RDONLY)) < 0 )
+	{
+		fprintf(stderr, "Cannot open device: %s.\n", argv[1]);
+		return(1);
+	}
+
+	if ( ioctl(fd, 1, 0) < 0 )
+	{
+		fprintf(stderr, "Failed on oops.\n");
+		return(1);
+	}
+
+	printf("OOoops\n");
+
+	close(fd);
+	return(0);
+}
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/syslogd.c sysklogd-1.3/syslogd.c
--- v1.3-1/sysklogd-1.3/syslogd.c	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/syslogd.c	Thu May  2 15:18:09 1996
@@ -269,6 +269,14 @@
  *	when syslogd starts up.
  *
  *	Minor code cleanups.
+ *
+ * Thu May  2 15:15:33 CDT 1996:  Dr. Wettstein
+ *	Fixed bug in init function which resulted in file descripters
+ *	being orphaned when syslogd process was re-initialized with SIGHUP
+ *	signal.  Thanks to Edvard Tuinder
+ *	(Edvard.Tuinder@praseodymium.cistron.nl) for putting me on the
+ *	trail of this bug.  I am amazed that we didn't catch this one
+ *	before now.
  */
 
 
@@ -1846,47 +1854,37 @@
 	register char *p;
 	char cline[BUFSIZ];
 
-	dprintf("Called init.\n");
 
 	/*
-	 *  Close all open log files.
+	 *  Close all open log files and free log descriptor array.
 	 */
+	dprintf("Called init.\n");
 	Initialized = 0;
 	if ( nlogs > -1 )
 	{
 		dprintf("Initializing log structures.\n");
+
+		for (lognum = 0; lognum <= nlogs; lognum++ ) {
+			f = &Files[lognum];
+
+			/* flush any pending output */
+			if (f->f_prevcount)
+				fprintlog(f, LocalHostName, 0, (char *)NULL);
+
+			switch (f->f_type) {
+				case F_FILE:
+				case F_TTY:
+				case F_CONSOLE:
+					(void) close(f->f_file);
+				break;
+			}
+		}
+
 		nlogs = -1;
 		free((void *) Files);
 		Files = (struct filed *) 0;
 	}
 	
-#ifdef SYSV
-	for (lognum = 0; lognum <= nlogs; lognum++ ) {
-		f = &Files[lognum];
-#else
-	for (f = Files; f != NULL; f = next) {
-#endif
-		/* flush any pending output */
-		if (f->f_prevcount)
-			fprintlog(f, LocalHostName, 0, (char *)NULL);
-
-		switch (f->f_type) {
-		  case F_FILE:
-		  case F_TTY:
-		  case F_CONSOLE:
-			(void) close(f->f_file);
-			break;
-		}
-#ifdef SYSV
-		f->f_type = F_UNUSED;	/* clear entry - ASP */
-	}
-#else
-		next = f->f_next;
-		free((char *) f);
-	}
-	Files = NULL;
-	nextp = &OBFiles;
-#endif
 
 	/* open the configuration file */
 	if ((cf = fopen(ConfFile, "r")) == NULL) {
diff -u --new-file --recursive v1.3-1/sysklogd-1.3/version.h sysklogd-1.3/version.h
--- v1.3-1/sysklogd-1.3/version.h	Sun Mar 31 11:19:05 1996
+++ sysklogd-1.3/version.h	Wed Apr 17 15:15:58 1996
@@ -1,2 +1,2 @@
 #define VERSION "1.3"
-#define PATCHLEVEL "1"
+#define PATCHLEVEL "2"
Cut here to complete separating patch 2. ----------------------------------

Cut here to begin separating patch 3. -------------------------------------
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/ANNOUNCE ./sysklogd-1.3/ANNOUNCE
--- v1.3-2/sysklogd-1.3/ANNOUNCE	Tue Feb 27 16:19:26 1996
+++ ./sysklogd-1.3/ANNOUNCE	Thu Aug 29 08:44:55 1996
@@ -1,6 +1,6 @@
-On behalf of Martin Schulze, the beta-testers and other members of the
-Linux INTERNET community who have helped shape and debug this package
-I am pleased to announce version 1.3 of the sysklogd package.
+On behalf of the beta-testers and other members of the Linux INTERNET
+community who have helped shape and debug this package I am pleased to
+announce version 1.3-pl3 of the sysklogd package.
 
 This package implements two system log daemons. The syslogd daemon is
 an enhanced version of the standard Berkeley utility program. This
@@ -26,6 +26,9 @@
 	* klogd supports on-the-fly kernel address to symbol
 	translations. This requires that a valid kernel symbol map be
 	found at execution.
+
+	* klogd also supports debugging of protection faults which occur
+	in kernel loadable modules.
 
 	* syslogd has better handling of remote logging capabilities.
 
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/MANIFEST ./sysklogd-1.3/MANIFEST
--- v1.3-2/sysklogd-1.3/MANIFEST	Fri Aug 30 11:19:11 1996
+++ ./sysklogd-1.3/MANIFEST	Thu Aug 29 10:02:33 1996
@@ -56,3 +56,7 @@
 
 oops_test.c:	A small driver program used in conjunction with the oops
 		module to generate a kernel protection fault.
+
+modules.patch:	A patch to the modules-2.0.0 package which provides for
+		automatic signalling of klogd whenever the kernel module
+		state changes.
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/NEWS ./sysklogd-1.3/NEWS
--- v1.3-2/sysklogd-1.3/NEWS	Fri Aug 30 11:19:10 1996
+++ ./sysklogd-1.3/NEWS	Fri Aug 30 11:13:28 1996
@@ -1,3 +1,42 @@
+Version 1.3 Patch Level 3
+
+General. ------------------------------------------------------------------
+Update to documentation including klogd.8 manpage to reflect new features.
+
+Included patch for modules-2.0.0 package to provide support for signalling
+klogd of changes in kernel module status.
+
+klogd ---------------------------------------------------------------------
+Provided support for signalling klogd to reload static and kernel module
+symbol information via SIGUSR1 and SIGUSR2.
+
+Implemented -p switch to cause a reload of kernel module symbol information
+whenever a protection fault is detected.
+
+Informative message is printed whenever klogd state change occurs.
+
+Added -i and -I switches to signal the currently executing klogd daemon
+to reload symbold information.
+
+
+Version 1.3 Patch Level 2
+
+General. ------------------------------------------------------------------
+Added oops.c and oops_test.c.  Oops.c implements a kernel loadable module
+which will generate a general protection fault.  The oops_test.c program
+generates a test program for exercising the loadable module.
+
+syslogd ------------------------------------------------------------------
+Fixed bug resulting in file descriptors being orphaned when syslogd was
+initialized via signal handler.
+
+klogd ---------------------------------------------------------------------
+Bug fix to prevent errors when reading symbol tables with 64 bit addresses.
+
+Added support for debugging of protection faults occuring in kernel
+loadable modules.
+
+
 Version 1.3 Patch Level 1
 
 General. ------------------------------------------------------------------
@@ -9,7 +48,6 @@
 
 Spelling and grammar corrections in the man pages.
 
-
 syslogd ------------------------------------------------------------------
 Patch to fix parsing of hostnames in syslogd.c.
 
@@ -18,7 +56,6 @@
 
 Bounds error fixed when setting the file descriptors for UNIX domain
 sockets.
-
 
 klogd ---------------------------------------------------------------------
 Error checking and reporting enhanced.  I have a couple of reports
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/Sysklogd-1.3.lsm ./sysklogd-1.3/Sysklogd-1.3.lsm
--- v1.3-2/sysklogd-1.3/Sysklogd-1.3.lsm	Tue Feb 27 16:22:57 1996
+++ ./sysklogd-1.3/Sysklogd-1.3.lsm	Fri Aug 30 10:52:39 1996
@@ -12,6 +12,8 @@
 		routes them to either output files or to syslogd.  This
 		version of klogd will optionally translate kernel addresses
 		to their symbolic equivalents if provided with a system map.
+		The klogd daemon also provides support for debugging of
+		protection faults which occur in kernel loadable modules.
 Keywords:       logging, remote, kernel, syslogd, proc, daemon, klogd
 Author:         greg@wind.rmcc.com (Dr. G.W. Wettstein)
 Maintained-by:  greg@wind.rmcc.com (Dr. G.W. Wettstein)
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/klogd.8 ./sysklogd-1.3/klogd.8
--- v1.3-2/sysklogd-1.3/klogd.8	Fri Dec 15 15:06:26 1995
+++ ./sysklogd-1.3/klogd.8	Fri Aug 30 11:00:56 1996
@@ -2,6 +2,7 @@
 .\" May be distributed under the GNU General Public License
 .\" Sun Jul 30 01:35:55 MET: Martin Schulze: Updates
 .\" Sun Nov 19 23:22:21 MET: Martin Schulze: Updates
+.\" Mon Aug 19 09:42:08 CDT 1996: Dr. G.W. Wettstein: Updates
 .\"
 .TH KLOGD 8 "24 November 1995" "Version 1.3" "Linux System Administration"
 .SH NAME
@@ -16,8 +17,10 @@
 .RB [ " \-f "
 .I fname
 ]
+.RB [ " \-iI " ]
 .RB [ " \-n " ]
 .RB [ " \-o " ]
+.RB [ " \-p " ]
 .RB [ " \-s " ]
 .RB [ " \-k "
 .I fname
@@ -41,6 +44,12 @@
 .BI "\-f " file
 Log messages to the specified filename rather than to the syslog facility.
 .TP
+.BI "\-i \-I"
+Signal the currently executing klogd daemon.  Both of these switches control
+the loading/reloading of symbol information.  The \-i switch signals the
+daemon to reload the kernel module symbols.  The \-I switch signals for a
+reload of both the static kernel symbols and the kernel module symbols.
+.TP
 .B "\-n"
 Avoid auto-backgrounding. This is needed especially if the
 .B klogd
@@ -52,6 +61,12 @@
 all the messages that are found in the kernel message buffers.  After
 a single read and log cycle the daemon exits.
 .TP
+.B "-p"
+Enable paranoia.  This option controls when klogd loads kernel module symbol
+information.  Setting this switch causes klogd to load the kernel module
+symbol information whenever an Oops string is detected in the kernel message
+stream.
+.TP
 .B "-s"
 Force \fBklogd\fP to use the system call interface to the kernel message
 buffers.
@@ -72,15 +87,15 @@
 
 In Linux there are two potential sources of kernel log information: the 
 .I /proc
-filesystem and the syscall (sys_syslog) interface, although
+file system and the syscall (sys_syslog) interface, although
 ultimately they are one and the same.  Klogd is designed to choose
 whichever source of information is the most appropriate.  It does this
 by first checking for the presence of a mounted 
 .I /proc
-filesystem. If this is found the 
+file system. If this is found the 
 .I /proc/kmsg
 file is used as the source of kernel log
-information. If the proc filesystem is not mounted 
+information. If the proc file system is not mounted 
 .B klogd
 uses a
 system call to obtain kernel messages.  The command line switch
@@ -163,10 +178,43 @@
 .fi
 .PP
 .SH KERNEL ADDRESS RESOLUTION
+If the kernel detects an internal error condition a general protection
+fault will be triggered.  As part of the GPF handling procedure the
+kernel prints out a status report indicating the state of the
+processor at the time of the fault.  Included in this display are the
+contents of the microprocessor's registers, the contents of the kernel
+stack and a tracing of what functions were being executed at the time
+of the fault.
+
+This information is
+.B EXTREMELY IMPORTANT
+in determining what caused the internal error condition.  The
+difficulty comes when a kernel developer attempts to analyze this
+information.  The raw numeric information present in the protection
+fault printout is of very little use to the developers.  This is due
+to the fact that kernels are not identical and the addresses of
+variable locations or functions will not be the same in all kernels.
+In order to correctly diagnose the cause of failure a kernel developer
+needs to know what specific kernel functions or variable locations
+were involved in the error.
+
+As part of the kernel compilation process a listing is created which
+specified the address locations of important variables and function in
+the kernel being compiled.  This listing is saved in a file called
+System.map in the top of the kernel directory source tree.  Using this
+listing a kernel developer can determine exactly what the kernel was
+doing when the error condition occurred.
+
+The process of resolving the numeric addresses from the protection
+fault printout can be done manually or by using the
+.B ksymoops
+program which is included in the kernel sources.
+
+As a convenience
 .B klogd
 will attempt to resolve kernel numeric addresses to their symbolic
-forms if a kernel symbol table is available at execution time.
-A symbol table may be specified by using the \fB\-k\fR switch on the
+forms if a kernel symbol table is available at execution time.  A
+symbol table may be specified by using the \fB\-k\fR switch on the
 command line.  If a symbol file is not explicitly specified the
 following filenames will be tried:
 
@@ -192,19 +240,101 @@
 so that they will be recognized and translated by klogd.  Earlier
 kernels require a source code patch be applied to the kernel sources.
 This patch is supplied with the sysklogd sources.
+
+The process of analyzing kernel protections faults works very well
+with a static kernel.  Additional difficulties are encountered when
+attempting to diagnose errors which occur in loadable kernel modules.
+Loadable kernel modules are used to implement kernel functionality in
+a form which can be loaded or unloaded at will.  The use of loadable
+modules is useful from a debugging standpoint and can also be useful
+in decreasing the amount of memory required by a kernel.
+
+The difficulty with diagnosing errors in loadable modules is due to
+the dynamic nature of the kernel modules.  When a module is loaded the
+kernel will allocate memory to hold the module, when the module is
+unloaded this memory will be returned back to the kernel.  This
+dynamic memory allocation makes it impossible to produce a map file
+which details the addresses of the variable and functions in a kernel
+loadable module.  Without this location map it is not possible for a
+kernel developer to determine what went wrong if a protection fault
+involves a kernel module.
+
+.B klogd
+has support for dealing with the problem of diagnosing protection
+faults in kernel loadable modules.  At program start time or in
+response to a signal the daemon will interrogate the kernel for a
+listing of all modules loaded and the addresses in memory they are
+loaded at.  Individual modules can also register the locations of
+important functions when the module is loaded.  The addresses of these
+exported symbols are also determined during this interrogation
+process.
+
+When a protection fault occurs an attempt will be made to resolve
+kernel addresses from the static symbol table.  If this fails the
+symbols from the currently loaded modules are examined in an attempt
+to resolve the addresses.  At the very minimum this allows klogd to
+indicate which loadable module was responsible for generating the
+protection fault.  Additional information may be available if the
+module developer chose to export symbol information from the module.
+
+Proper and accurate resolution of addresses in kernel modules requires
+that
+.B klogd
+be informed whenever the kernel module status changes.  The
+.B \-i
+and
+.B \-I
+switches can be used to signal the currently executing daemon that
+symbol information be reloaded.  Of most importance to proper
+resolution of module symbols is the
+.B \-i
+switch.  Each time a kernel module is loaded or removed from the
+kernel the following command should be executed:
+
+.nf
+.I klogd \-i
+.fi
+
+The
+.B \-p
+switch can also be used to insure that module symbol information is up
+to date.  This switch instructs
+.B klogd
+to reload the module symbol information whenever a protection fault
+is detected.  Caution should be used before invoking the program in
+\'paranoid\' mode.  The stability of the kernel and the operating
+environment is always under question when a protection fault occurs.
+Since the klogd daemon must execute system calls in order to read the
+module symbol information there is the possibility that the system may
+be too unstable to capture useful information.  A much better policy
+is to insure that klogd is updated whenever a module is loaded or
+unloaded.  Having uptodate symbol information loaded increases the
+probability of properly resolving a protection fault if it should occur.
+
+Included in the sysklogd source distribution is a patch to the
+modules-2.0.0 package which allows the
+.B insmod,
+.B rmmod
+and
+.B modprobe
+utilities to automatically signal
+.B klogd
+whenever a module is inserted or removed from the kernel.  Using this
+patch will insure that the symbol information maintained in klogd is
+always consistent with the current kernel state.
 .PP
 .SH SIGNAL HANDLING
 The 
 .B klogd
-will respond to six signals:
-.BR SIGHUP ", " SIGINT ", " SIGKILL ", " SIGTERM ", " SIGTSTP " and " SIGCONT ". The"
+will respond to eight signals:
+.BR SIGHUP ", " SIGINT ", " SIGKILL ", " SIGTERM ", " SIGTSTP ", " SIGUSR1 ", "SIGUSR2 " and " SIGCONT ". The"
 .BR SIGINT ", " SIGKILL ", " SIGTERM " and " SIGHUP
 signals will cause the daemon to close its kernel log sources and
 terminate gracefully.
 
 The 
 .BR SIGTSTP " and " SIGCONT
-singals are used to start and stop kernel logging. Upon receipt of a 
+signals are used to start and stop kernel logging. Upon receipt of a 
 .B SIGTSTP
 signal the daemon will close its
 log sources and spin in an idle loop.  Subsequent receipt of a 
@@ -229,6 +359,26 @@
 .B LOG_INFO
 priority
 documenting the start/stop of logging.
+
+The 
+.BR SIGUSR1 " and " SIGUSR2
+signals are used to initiate loading/reloading of kernel symbol information.
+Receipt of the
+.B SIGUSR1
+signal will cause the kernel module symbols to be reloaded.  Signaling the
+daemon with
+.B SIGUSR2
+will cause both the static kernel symbols and the kernel module symbols to
+be reloaded.
+
+Provided that the System.map file is placed in an appropriate location the
+signal of generally greatest usefulness is the
+.B SIGUSR1
+signal.  This signal is designed to be used to signal the daemon when kernel
+modules are loaded/unloaded.  Sending this signal to the daemon after a
+kernel module state change will insure that proper resolution of symbols will
+occur if a protection fault occurs in the address space occupied by a kernel
+module.
 .LP
 .SH FILES
 .PD 0
@@ -241,7 +391,7 @@
 The file containing the process id of 
 .B klogd
 .TP
-.I /System.map, /usr/src/linux/System.map
+.I /boot/System.map, /System.map, /usr/src/linux/System.map
 Default locations for kernel system maps.
 .PD
 .SH BUGS
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/klogd.c ./sysklogd-1.3/klogd.c
--- v1.3-2/sysklogd-1.3/klogd.c	Fri Aug 30 11:19:11 1996
+++ ./sysklogd-1.3/klogd.c	Wed Aug 21 09:15:17 1996
@@ -141,6 +141,18 @@
  *	termination cleanup sequence.  This minimizes the potential for
  *	conflicting pidfiles causing immediate termination at boot time.
  *	
+ * Wed Aug 21 09:13:03 CDT 1996:  Dr. Wettstein
+ *	Added ability to reload static symbols and kernel module symbols
+ *      under control of SIGUSR1 and SIGUSR2 signals.
+ *
+ *	Added -p switch to select 'paranoid' behavior with respect to the
+ *	loading of kernel module symbols.
+ *
+ *	Informative line now printed whenever a state change occurs due
+ *	to signal reception by the daemon.
+ *
+ *	Added the -i and -I command line switches to signal the currently
+ *	executing daemon.
  */
 
 
@@ -177,13 +189,15 @@
 		change_state = 0,
 		terminate = 0,
 		caught_TSTP = 0,
+		reload_symbols = 0,
 		console_log_level = 6;
 
 static int	use_syscall = 0,
 		one_shot = 0,
 		NoFork = 0;	/* don't fork - don't run in daemon mode */
 
-static char log_buffer[LOG_BUFFER_SIZE];
+static char	*symfile = (char *) 0,
+		log_buffer[LOG_BUFFER_SIZE];
 
 static FILE *output_file = (FILE *) 0;
 
@@ -198,7 +212,10 @@
 extern void restart(int sig);
 extern void stop_logging(int sig);
 extern void stop_daemon(int sig);
+extern void reload_daemon(int sig);
 static void Terminate(void);
+static void SignalDaemon(int);
+static void ReloadSymbols(void);
 static void ChangeLogging(void);
 static enum LOGSRC GetKernelLogSrc(void);
 static void LogLine(char *ptr, int len);
@@ -269,6 +286,27 @@
 }
 
 
+void reload_daemon(sig)
+
+     int sig;
+
+{
+	change_state = 1;
+	reload_symbols = 1;
+
+
+	if ( sig == SIGUSR2 )
+	{
+		++reload_symbols;
+		signal(SIGUSR2, reload_daemon);
+	}
+	else
+		signal(SIGUSR1, reload_daemon);
+		
+	return;
+}
+
+
 static void Terminate()
 
 {
@@ -282,7 +320,29 @@
 	exit(1);
 }
 
-	
+static void SignalDaemon(sig)
+
+     int sig;
+
+{
+	auto int pid = check_pid(PidFile);
+
+	kill(pid, sig);
+	return;
+}
+
+
+static void ReloadSymbols()
+
+{
+	if ( reload_symbols > 1 )
+		InitKsyms(symfile);
+	InitMsyms();
+	reload_symbols = change_state = 0;
+	return;
+}
+
+
 static void ChangeLogging(void)
 
 {
@@ -290,6 +350,17 @@
 	if ( terminate == 1 )
 		Terminate();
 
+	/* Indicate that something is happening. */
+	Syslog(LOG_INFO, "klogd %s-%s, ---------- state change ----------\n", \
+	       VERSION, PATCHLEVEL);
+
+	/* Reload symbols. */
+	if ( reload_symbols > 0 )
+	{
+		ReloadSymbols();
+		return;
+	}
+
 	/* Stop kernel logging. */
 	if ( caught_TSTP == 1 )
 	{
@@ -566,14 +637,14 @@
 	char *argv[];
 
 {
-	auto int ch, use_output = 0;
+	auto int	ch,
+			use_output = 0;
 
-	auto char	*symfile = (char *) 0,
-			*log_level = (char *) 0,
+	auto char	*log_level = (char *) 0,
 			*output = (char *) 0;
 
 	/* Parse the command-line. */
-	while ((ch = getopt(argc, argv, "c:df:k:nosv")) != EOF)
+	while ((ch = getopt(argc, argv, "c:df:iIk:nopsv")) != EOF)
 		switch((char)ch)
 		{
 		    case 'c':		/* Set console message level. */
@@ -586,6 +657,12 @@
 			output = optarg;
 			use_output++;
 			break;
+		    case 'i':		/* Reload module symbols. */
+			SignalDaemon(SIGUSR1);
+			return(0);
+		    case 'I':
+			SignalDaemon(SIGUSR2);
+			return(0);
 		    case 'k':		/* Kernel symbol file. */
 			symfile = optarg;
 			break;
@@ -595,6 +672,9 @@
 		    case 'o':		/* One-shot mode. */
 			one_shot = 1;
 			break;
+		    case 'p':
+			SetParanoiaLevel(1);	/* Load symbols on oops. */
+			break;	
 		    case 's':		/* Use syscall interface. */
 			use_syscall = 1;
 			break;
@@ -682,6 +762,8 @@
 	signal(SIGHUP, stop_daemon);
 	signal(SIGTSTP, stop_logging);
 	signal(SIGCONT, restart);
+	signal(SIGUSR1, reload_daemon);
+	signal(SIGUSR2, reload_daemon);
 
 
 	/* Open outputs. */
@@ -704,6 +786,7 @@
 	if ( one_shot )
 	{
 		InitKsyms(symfile);
+		InitMsyms();
 		if ( (logsrc = GetKernelLogSrc()) == kernel )
 			LogKernelLine();
 		else
@@ -717,6 +800,7 @@
 #endif
 	logsrc = GetKernelLogSrc();
 	InitKsyms(symfile);
+	InitMsyms();
 
         /* The main loop. */
 	while (1)
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/klogd.h ./sysklogd-1.3/klogd.h
--- v1.3-2/sysklogd-1.3/klogd.h	Fri Aug 30 11:19:11 1996
+++ ./sysklogd-1.3/klogd.h	Tue Jul 30 10:57:17 1996
@@ -15,4 +15,5 @@
 extern int InitKsyms(char *);
 extern int InitMsyms(void);
 extern char * ExpandKadds(char *, char *);
+extern void SetParanoiaLevel(int);
 extern void Syslog(int priority, char *fmt, ...);
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/ksym.c ./sysklogd-1.3/ksym.c
--- v1.3-2/sysklogd-1.3/ksym.c	Fri Aug 30 11:19:12 1996
+++ ./sysklogd-1.3/ksym.c	Wed Aug 21 09:19:14 1996
@@ -62,6 +62,16 @@
  *	Added patch from beta-testers to allow for reading of both
  *	ELF and a.out map files.
  *
+ * Wed Aug 21 09:15:49 CDT 1996:  Dr. Wettstein
+ *	Reloading of kernel module symbols is now turned on by the
+ *	SetParanoiaLevel function.  The default behavior is to NOT reload
+ *	the kernel module symbols when a protection fault is detected.
+ *
+ *	Added support for freeing of the current kernel module symbols.
+ *	This was necessary to support reloading of the kernel module symbols.
+ *
+ *	When a matching static symbol table is loaded the kernel version
+ *	number is printed.
  */
 
 
@@ -83,6 +93,8 @@
 };
 
 static int num_syms = 0;
+static int i_am_paranoid = 0;
+static char vstring[12];
 static struct sym_table *sym_array = (struct sym_table *) 0;
 
 static char *system_maps[] =
@@ -108,6 +120,7 @@
 static char * FindSymbolFile(void);
 static int AddSymbol(unsigned long, char*);
 static char * LookupSymbol(unsigned long, struct symbol *);
+static void FreeSymbols(void);
 static int CheckVersion(char *);
 
 
@@ -144,6 +157,11 @@
 	auto FILE *sym_file;
 
 
+	/* Check and make sure that we are starting with a clean slate. */
+	if ( num_syms > 0 )
+		FreeSymbols();
+
+
 	/*
 	 * Search for and open the file containing the kernel symbols.
 	 */
@@ -222,7 +240,7 @@
 		break;
 		
 	    case 1:
-		Syslog(LOG_INFO, "Symbols match kernel version.");
+		Syslog(LOG_INFO, "Symbols match kernel version %s.", vstring);
 		break;
 	}
 		
@@ -397,8 +415,6 @@
 	
 
 {
-	auto char vstring[6];
-
 	auto int	vnum,
 			major,
 			minor,
@@ -423,16 +439,15 @@
 	 * things out by decoding the version string into its component
 	 * parts.
 	 */
-	memset(vstring, '\0', sizeof(vstring));
-	strncpy(vstring, version + strlen(prefix), sizeof(vstring)-1);
-	vnum = atoi(vstring);
+	vnum = atoi(version + strlen(prefix));
 	major = vnum / 65536;
 	vnum -= (major * 65536);
 	minor = vnum / 256;
 	patch = vnum - (minor * 256);
 	if ( debugging )
 		fprintf(stderr, "Version string = %s, Major = %d, " \
-		       "Minor = %d, Patch = %d.\n", vstring, major, minor, \
+		       "Minor = %d, Patch = %d.\n", version +
+		       strlen(prefix), major, minor, \
 		       patch);
 	sprintf(vstring, "%d.%d.%d", major, minor, patch);
 
@@ -558,6 +573,37 @@
 
 
 /**************************************************************************
+ * Function:	FreeSymbols
+ *
+ * Purpose:	This function is responsible for freeing all memory which
+ *		has been allocated to hold the static symbol table.  It
+ *		also initializes the symbol count and in general prepares
+ *		for a re-read of a static symbol table.
+ *
+ * Arguements:  void
+ *
+ * Return:	void
+ **************************************************************************/
+
+static void FreeSymbols()
+
+{
+	auto int lp;
+
+	/* Free each piece of memory allocated for symbol names. */
+	for(lp= 0; lp < num_syms; ++lp)
+		free(sym_array[lp].name);
+
+	/* Whack the entire array and initialize everything. */
+	free(sym_array);
+	sym_array = (struct sym_table *) 0;
+	num_syms = 0;
+
+	return;
+}
+
+
+/**************************************************************************
  * Function:	LogExpanded
  *
  * Purpose:	This function is responsible for logging a kernel message
@@ -610,7 +656,8 @@
 	 * kernel whenever a module is loaded or unloaded.  I am
 	 * open for patches.
 	 */
-	if ( (strstr(line, "Oops:") != (char *) 0) && !InitMsyms() )
+	if ( i_am_paranoid &&
+	     (strstr(line, "Oops:") != (char *) 0) && !InitMsyms() )
 		Syslog(LOG_WARNING, "Cannot load kernel module symbols.\n");
 	
 
@@ -670,6 +717,30 @@
 	if ( debugging )
 		fprintf(stderr, "Expanded line: %s\n", el);
 	return(el);
+}
+
+
+/**************************************************************************
+ * Function:	SetParanoiaLevel
+ *
+ * Purpose:	This function is an interface function for setting the
+ *		mode of loadable module symbol lookups.  Probably overkill
+ *		but it does slay another global variable.
+ *
+ * Arguements:	(int) level
+ *
+ *		level:->	The amount of paranoia which is to be
+ *				present when resolving kernel exceptions.
+ * Return:	void
+ **************************************************************************/
+
+extern void SetParanoiaLevel(level)
+
+	int level;
+
+{
+	i_am_paranoid = level;
+	return;
 }
 
 
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/ksym_mod.c ./sysklogd-1.3/ksym_mod.c
--- v1.3-2/sysklogd-1.3/ksym_mod.c	Fri Aug 30 11:19:12 1996
+++ ./sysklogd-1.3/ksym_mod.c	Fri Aug 23 11:45:27 1996
@@ -37,6 +37,15 @@
  * possible.
  *
  * At least that is the plan.
+ *
+ * Wed Aug 21 09:20:09 CDT 1996:  Dr. Wettstein
+ *	The situation where no module support has been compiled into a
+ *	kernel is now detected.  An informative message is output indicating
+ *	that the kernel has no loadable module support whenever kernel
+ *	module symbols are loaded.
+ *
+ *	An informative message is printed indicating the number of kernel
+ *	modules and the number of symbols loaded from these modules.
  */
 
 
@@ -65,7 +74,7 @@
  */
 #define __LIBRARY__
 #include <linux/unistd.h>
-# define __NR_getsyms __NR_get_kernel_syms
+#define __NR_getsyms __NR_get_kernel_syms
 _syscall1(int, getsyms, struct kernel_sym *, syms);
 #undef __LIBRARY__
 extern int getsyms(struct kernel_sym *);
@@ -87,7 +96,7 @@
 	struct module module;
 };
 
-static int num_modules;
+static int num_modules = 0;
 struct Module *sym_array_modules = (struct Module *) 0;
 
 static int have_modules = 0;
@@ -132,9 +141,8 @@
 				*p;
 
 
-	/* Init the symbol table if one exists. */
-	if ( num_modules > 0 )
-		FreeModules();
+	/* Initialize the kernel module symbol table. */
+	FreeModules();
 
 
 	/*
@@ -153,7 +161,16 @@
 	 *
 	 * Bummer.
 	 */
-	rtn = getsyms((struct kernel_sym *) 0);
+	if ( (rtn = getsyms((struct kernel_sym *) 0)) < 0 )
+	{
+		if ( errno == ENOSYS )
+			Syslog(LOG_INFO, "No module symbols loaded - "
+			       "kernel modules not enabled.\n");
+		else
+			Syslog(LOG_ERR, "Error loading kernel symbols " \
+			       "- %s\n", strerror(errno));
+		return(0);
+	}
 	if ( debugging )
 		fprintf(stderr, "Loading kernel module symbols - "
 			"Size of table: %d\n", rtn);
@@ -162,12 +179,16 @@
 						  sizeof(struct kernel_sym));
 	if ( ksym_table == (struct kernel_sym *) 0 )
 	{
-		Syslog(LOG_WARNING, " Failed memory allocation for kernel "
+		Syslog(LOG_WARNING, " Failed memory allocation for kernel " \
 		       "symbol table.\n");
 		return(0);
 	}
-	if ( (rtn = getsyms(ksym_table)) == 0 )
-		Syslog(LOG_WARNING, "Kernel symbol read returned 0\n");
+	if ( (rtn = getsyms(ksym_table)) < 0 )
+	{
+		Syslog(LOG_WARNING, "Error reading kernel symbols - %s\n", \
+		       strerror(errno));
+		return(0);
+	}
 
 
 	/*
@@ -189,8 +210,9 @@
 	}
 
 	/* Sort the symbol tables in each module. */
-	for (tmp= 0; tmp < num_modules; ++tmp)
+	for (rtn = tmp= 0; tmp < num_modules; ++tmp)
 	{
+		rtn += sym_array_modules[tmp].num_syms;
 		if ( sym_array_modules[tmp].num_syms < 2 )
 			continue;
 		qsort(sym_array_modules[tmp].sym_array, \
@@ -198,6 +220,12 @@
 		      sizeof(struct sym_table), symsort);
 	}
 
+	if ( rtn == 0 )
+		Syslog(LOG_INFO, "No module symbols loaded.");
+	else
+		Syslog(LOG_INFO, "Loaded %d %s from %d module%s", rtn, \
+		       (rtn == 1) ? "symbol" : "symbols", \
+		       num_modules, (num_modules == 1) ? "." : "s.");
 	free(ksym_table);
 	return(1);
 }
@@ -241,7 +269,13 @@
 	auto struct Module *mp;
 
 
-	for (nmods= 0; nmods <num_modules; ++nmods)
+	/* Check to see if the module symbol tables need to be cleared. */
+	have_modules = 0;
+	if ( num_modules == 0 )
+		return;
+
+
+	for (nmods= 0; nmods < num_modules; ++nmods)
 	{
 		mp = &sym_array_modules[nmods];
 		if ( mp->num_syms == 0 )
@@ -254,7 +288,7 @@
 
 	free(sym_array_modules);
 	sym_array_modules = (struct Module *) 0;
-	have_modules = num_modules = 0;
+	num_modules = 0;
 	return;
 }
 
@@ -296,6 +330,7 @@
 	 */
 	if ( symbol[0] == '#' )
 	{
+
 		if ( symbol[1] == '\0' )
 		{
 			/*
@@ -307,7 +342,6 @@
 			have_modules = 1;
 			return(1);
 		}
-
 		/* Allocate space for the module. */
 		sym_array_modules = (struct Module *) \
 			realloc(sym_array_modules, \
@@ -584,4 +618,19 @@
 	FreeModules();
 	return(0);
 }
+
+extern void Syslog(int priority, char *fmt, ...)
+
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	fprintf(stdout, "Pr: %d, ", priority);
+	vfprintf(stdout, fmt, ap);
+	va_end(ap);
+	fputc('\n', stdout);
+
+	return;
+}
+
 #endif
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/modutils.patch ./sysklogd-1.3/modutils.patch
--- v1.3-2/sysklogd-1.3/modutils.patch	Wed Dec 31 18:00:00 1969
+++ ./sysklogd-1.3/modutils.patch	Thu Aug 29 10:00:32 1996
@@ -0,0 +1,65 @@
+diff -u --new-file --recursive base/modules-2.0.0/depmod/modprobe.c ./modules-2.0.0/depmod/modprobe.c
+--- base/modules-2.0.0/depmod/modprobe.c	Mon Jun 10 05:29:08 1996
++++ ./modules-2.0.0/depmod/modprobe.c	Thu Aug 29 09:58:01 1996
+@@ -233,6 +233,13 @@
+ 	verbose ("\r\t%s\n\t\t",cmd);
+ 	int ret = system(cmd);
+ #endif
++	if ( fork() == 0 )
++	{
++		/* Child process. */
++		if ( execlp("klogd", "klogd", "-i", (char *) 0)  < 0 )
++			fprintf(stderr, "Failure in signaling klogd.\n");
++		exit(0);
++	}
+ 	return ret;
+ }
+ /*
+diff -u --new-file --recursive base/modules-2.0.0/insmod/insmod.c ./modules-2.0.0/insmod/insmod.c
+--- base/modules-2.0.0/insmod/insmod.c	Mon Jun 10 06:42:25 1996
++++ ./modules-2.0.0/insmod/insmod.c	Thu Aug 29 09:56:53 1996
+@@ -253,6 +253,18 @@
+ 	++n_stringpatches;
+ }
+ 
++
++void signal_klogd() {
++	if ( fork() == 0 )
++	{
++		if ( execlp("klogd", "klogd", "-i", (char *) 0)  < 0 )
++			fprintf(stderr, "Failure in signaling klogd.\n");
++		exit(0);
++	}
++	return;
++}
++
++
+ int main(int argc, char **argv)
+ {
+ 	FILE *fp;
+@@ -983,6 +995,8 @@
+ 			symvalue(sp) + addr, symtype, symname(sp));
+ 	}
+ 
++	signal_klogd();
++
+ 	if (nksyms > 0)
+ 		free(ksymtab); /* it has done its job */
+ 
+@@ -1292,6 +1306,7 @@
+ 			--argc;
+ 			++argv;
+ 		}
++		signal_klogd();
+ 		return errors;
+ 	}
+ 	/* else recursive removal */
+@@ -1353,6 +1368,8 @@
+ 			break;
+ 		}
+ 	}
++
++	signal_klogd();
+ 
+ 	return errors;
+ }
diff -u --new-file --recursive v1.3-2/sysklogd-1.3/version.h ./sysklogd-1.3/version.h
--- v1.3-2/sysklogd-1.3/version.h	Fri Aug 30 11:19:13 1996
+++ ./sysklogd-1.3/version.h	Fri Jul 12 13:03:12 1996
@@ -1,2 +1,2 @@
 #define VERSION "1.3"
-#define PATCHLEVEL "2"
+#define PATCHLEVEL "3"
Cut here to complete separating patch 3. ----------------------------------

}-- End of excerpt from "John M. Fisk"

As always,
Dr. G.W. Wettstein           Oncology Research Div. Computing Facility
Roger Maris Cancer Center    INTERNET: greg@wind.rmcc.com
820 4th St. N.
Fargo, ND  58122
Phone: 701-234-7556
------------------------------------------------------------------------------
"A computer without Windows is like a fish without a bicycle."
				-- Chris Woods

