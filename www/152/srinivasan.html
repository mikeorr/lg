<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="utf-8" xml:lang="utf-8">
<head>
<title>A Slightly Advanced Introduction to Vim LG #152</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../lg.css" type="text/css" media="screen, projection"  />
<link rel="alternate" type="application/rss+xml" title="LG RSS" href="lg.rss" />
<link rel="alternate" type="application/rdf+xml" title="LG RDF" href="lg.rdf" />
<!-- link rel="alternate" type="application/atom+xml" title="LG Atom" href="lg.atom.xml" / -->
<link rel="shortcut icon" href="../favicon.ico" />

<style type="text/css" media="screen, projection">
<!--

-->
</style>

</head>
<body>

<a href="../">
<img src="../gx/2003/newlogo-blank-200-gold2.jpg" id="logo" alt="Linux Gazette"/>
</a>
<p id="fun">...making Linux just a little more fun!</p>

<div id="navigation">
<table summary="masthead" width="100%">
<tr>
<td align="center" colspan="3" style="font-size: 10px; font-weight: bold">
<a href="../index.html">Home</a>
<a href="http://linuxgazette.net">Main Site</a>
<a href="../faq/index.html">FAQ</a>

<a href="../lg_index.html">Site Map</a>
<a href="../mirrors.html">Mirrors</a>
<a href="../mirrors.html">Translations</a>
<a href="../search.html">Search</a>
<a href="../archives.html">Archives</a>
<a href="../authors/index.html">Authors</a>
<a href="http://lists.linuxgazette.net/mailman/listinfo/">Mailing Lists</a>
<a href="../jobs.html">Join Us!</a>
<a href="../contact.html">Contact Us</a>

<hr width="99%" style="border: 1px inset #000033">
</td>
</tr>
<tr>
<td width="40%" align="left" style="font-size: 10px; font-weight: bold">
The Free International Online Linux Monthly
</td>
<td width="20%" align="center" style="font-size: 10px; font-weight: bold">
ISSN: 1934-371X
</td>
<td width="40%" align="right" style="font-size: 10px; font-weight: bold">
Main site: <a href="http://linuxgazette.net">http://linuxgazette.net</a> 
</td>
</table>
</div>


<div id="breadcrumbs1">

<a href="../index.html">Home</a> &gt; 
<a href="index.html">July 2008 (#152)</a> &gt; 
Article

</div>

<div class="articlecontent1">
<div class="content">

<div id="previousnexttop">
<A HREF="ramanathan.html" >&lt;-- prev</A> | <A HREF="collinge.html" >next --&gt;</A>
</div>

<h1>A Slightly Advanced Introduction to Vim</h1>
<p id="by"><b>By <a href="../authors/srinivasan.html">Pranesh Srinivasan</a></b></p>

<h3>What is it?</h3>

<pre>
        "It is the little things that make up great men." 
</pre>

<p>
This introduction is about the little things. Things that help ease everyday tasks but go a 
long way into making you a better user, editor, programmer - a better computer user.
</p>

<p>
This piece started out as a 'write-while-you-learn' exercise while reading a vim tutorial.
As I kept writing, I felt that with a little more work, and some polishing, this could
be turned into vim introduction of sorts.
</p>


<h3>Who is it for?</h3>
<p>
This is not a five minute introduction to vim for a complete newbie. I presume you have used vim before 
and are comfortable with moving around, and making changes. Although <em>:vimtutor</em> is not a 
prerequisite to this tutorial, I highly recommend it.
</p>

<p>
This document contains some mnemonics, and some slightly advanced features of vim that can 
help the average vim user/programmer increase his/her productivity by leaps and bounds.
</p>


<h3>Why does it exist?</h3>
<p>
I find a large number of people around me who have used vim a few times while writing 
programs. Very few of them have grown into becoming effective vim users. The majority drop out
because of its initially daunting interface. A good number of the interested users switch
to emacs, because they think the 'power' just isn't there with vim. I am not saying emacs
is bad, but I just cannot stand decisions made on lack of information.
</p>

<p>
This document is written with an aim to convert the odd
"I-just-use-vim-over-ssh" user to a full-fledged user, and to illustrate
the kind of power that vim provides.
</p>

<p>
Most importantly, vim is not just for programmers; it can be used by anybody and everybody
who deals with text in any form. Vim runs on many platforms including Mac, Windows, and Solaris, and 
is a standard on every Linux machine. Someday you might find yourself sitting on a terminal
with only vim installed.
</p>

<h3>Some Notation</h3>

<p>
Any command mentioned here is to be typed in the <tt>normal</tt> mode. The normal
mode is the mode one gets when he/she presses <em>&lt;Esc&gt;</em> in vim.
There are three main modes in vim: <tt>insert</tt>, <tt>normal</tt> and <tt>visual</tt>
(vim documentation says there are six BASIC and five Additional modes...)
</p>

<p>
Commands are generally indented with respect to the rest of the text. Any command prefixed by a ":" is 
also to be typed in the normal mode, with the colon. Of course they have to be suffixed by
an 'Enter' or carriage return.
</p>

<p>
In cases where a command has to be typed in the <tt>visual</tt> mode, it will be mentioned explicitly.
</p>

<p>
The commands described here should work with any recent version of vim, or gvim.
I used vim 7.0 for this, and some features like omni-completion and spell checking
are available only on it. If several commands in this document do not work, you might
wish to try <em>:set nocompatible</em> followed by a carriage return or 'Enter' in your vim.
</p>

<h3>Just in case</h3>
<p>
Just in case you are new to vim, or have completely forgotten the vim commands, and are still
brave and enthusiastic to try reading this, I won't leave you behind. Here is a five minute 
tutorial to vim.
</p>

<p>
Type 'vim' followed by a filename in your prompt to bring up vim.
</p>
 
<pre>
	$ vim filename
	# Or, for a GUI interface:
	$ gvim filename
</pre>

<p>
This will launch vim with the default directory in vim set to the directory the terminal was in.
</p>

<p>
You can quit vim by typing 
</p>

<pre>
	:q
	# Or, for the 'quit without saving' mode:
	:q!
</pre>

<p>
Once, in vim, you can move around using <em>h</em>, <em>j</em>, <em>k</em>, and <em>l</em>.
</p>

<pre>
        h - left
        j - down
        k - up 
        l - right
</pre>
        
<p>
Try to refrain from using the arrow keys. These keys were chosen, because
they lie on the home row and save the user a lot of time, and unnecessary
fumbling with the arrow keys. After you get used to them, you'll hate
having to use arrow keys in other text editors.
</p>

<p>
To insert text at a location, hit <em>i</em>. This will put you into insert
mode. The bottom left of your screen should read something similar to 
</p>

<pre>
        -- INSERT --
</pre>

<p class="editorial">[ This presumes that 'showmode' has been set. If you
don't see the above, and would like to, add 'set showmode' to your ~/.vimrc
file. -- Ben ]
</p>

<p>
Type in text till you are done. Use backspace if necessary. Avoid using
delete and the arrow keys.  If you are done, or you think you need to
navigate elsewhere, hit <em>&lt;ESC&gt;</em>. <em>Control+[</em> should
also do.  I do not recommend the second however, since it is present only
as backward compatibility on several old machines that did not have the
<em>Esc</em> Key.
</p>

<p>
You are now back into the normal mode. You can move around with <em>h</em>,
<em>j</em>, <em>k</em>, <em>l</em> again. That should be just enough. Spend
some time trying to get comfortable with it.
</p>

<p>
Save and exit with
</p>

<pre>
        :w followed by :q
        or simply :wq
</pre>

<p>
<em>Let's begin!</em>
</p>

<h3>The art of insertion</h3>
<p>
Several people around me often tell me that their greatest difficulty with
a major-mode editor like vim, is that they never know which mode they are
in.
</p>

<p>
If you are one like them, the answer is pretty simple. Vim was not designed
to be used the way you are using it. Vim was designed for short bursts of
insertion. Vim was designed around the idea that people tend to type text
for a much shorter time than they spend reading, editing, and revising it.
Therefore if you need to get up for coffee, or pick up the phone, or are
done with that sentence of yours, hit the <em>Esc</em> button.
</p>

<p>
Vim provides several keys to help you get to the right cursor position to
insert characters.  We list some of the more useful ones here.
</p>

<pre>
        i               insert BEFORE Cursor
        a               insert AFTER Cursor (append)

        shift+i (or I)  insert at BEGINNING of line
        shift+a (or A)  append at the END of line
</pre>

<p>
Noticing similarities? Good, because that is what vim is about. A lot of vim is actually very
intuitive. 
</p>

<p>
<em>Great! So how do you go about creating new lines?</em>
</p>
<pre>
        o               create a new line BELOW the current line, and put the cursor at the start of
                        the new line.

        shift+o (or O)  create a new line ABOVE the current line, and put the cursor at the start of
                        the new line
</pre>
        
<p>
<em>Wonderful! I do not have to &lt;End&gt;&lt;Enter&gt; or &lt;Home&gt;&lt;Shift+Enter&gt;. How do I edit text?</em>
</p>

<pre>
        r               replace the char at the cursor position and come back into escape mode.
                        In other words, replace a char
        shift+r (or R)  go into what people would generally call the replace mode. Vim is pretty 
                        intelligent. Have a look at how the backspace works in this mode.
</pre>
        
<p>
<em>Ok! How do I remove characters?</em>
</p>

<pre>
        x               remove char under the cursor. Similar to delete.
        shift+x (or X)  remove char before cursor. Works like backspace.
</pre>

<h3>Visual Mode</h3>

<p>
Selecting in vim, can be done with the mouse, if mousemodel is set
properly. See <em>:help mousemodel</em> on this.  But the recommended way
of selecting is to use the visual mode.
</p>

<p>
In normal mode, hit <em>v</em> . You will notice at the bottom left of your screen
</p>

<pre>
                -- VISUAL --
</pre>

<p>
or something similar.
</p>

<p>
Moving around with <em>h</em>, <em>j</em>, <em>k</em>, <em>l</em> will now
select text. You can delete (cut) the selection with <em>x</em>, or copy,
paste, them with keys <em>y</em> and <em>p</em>. As soon as you have done
any of these, you should be out of visual mode.  To otherwise exit visual
mode, you can hit the magic key, <em>Esc</em>.
</p>

<p>
<em>y</em> stands for Yank and <em>p</em> for Paste. Try them out. More on this will follow.
</p>

<h3>Undo and Redo</h3>
<p>
With all that copying and pasting, you are bound to make mistakes. So how do you undo? Control+Z? No. In normal
mode simply hit <em>u</em> . Are you beginning to see the power of major modes here? Keys are often very 
short and intuitive.
</p>

<p>
How do you redo? <em>r</em>? No, both <em>r</em> and <em>R</em> were taken
by replace modes. You do <em>Control+R</em> to redo.
</p>

<p>
How much can you undo? Quite a lot actually. In the more recent versions,
you can undo to any point since the current session of vim was started.
</p>

<p>
The latest version of vim at the time of writing, vim 7.0 even has support
for undo branches.
</p>

<p>
You can say something like
</p>

<pre>
	:earlier 10m
	
	 # or
	
	:earlier 2h
</pre>

<p>
and it would take you to 10 minutes or 2 hours ago. (If vim was open two
hours ago.)
</p>

<p>
Similarly <em>:later</em>.
</p>

<p>
What we have covered so far, are just the mere basics. This is stuff that
most people know. If you didn't, you do now! What comes from here on is the
important part. Learning to use vim as a Swiss Army knife for text and
programming.
</p>

<h3>Copying, Deleting, Pasting</h3>

<p>
In vim, a selection can be copied by yanking, or <em>y</em>. This is
different from emacs' yank, which pastes. In vim, the paste command is
<em>p</em>. Pasting and yanking can be done into registers too.  There are
no deletes in vim. Everything goes into the paste buffer - or, optionally,
into a register named with a single character from the {a-zA-Z0-9} list.
</p>

<pre>
        y       : copy selection. (Use visual or implicitly copy like yas to yank a sentence - see 
                  Mnemonics below)
        yy      : copy current line.
        Y       : copy current line.
        d       : delete (cut) selection. Same usage as y.
        dd      : delete (cut) current line.
        D       : delete from here till end of line.
        p       : paste selection (Pasting is intelligent. If you copy a whole line, it will put 
                  it below the current line.) see 'ddp' below in keyboard combos

</pre>
<p>
Note that the scope of the action of <em>Y</em> is different from that of
<em>D</em>; indeed, <em>Y</em> = <em>yy</em>. If you want to set it to what
would you have expected normally read the section on mapping below.
</p>

<pre>
        "fy     : copy selection and paste in register f
        "fd     : delete selection and paste in register f
        (This works with "xyy "xY and all other similar things too.)

        "fp     : paste what is present in registers f.
</pre>

<p>
You can look at the registers by using the ':reg[isters]' command.  In your
version of vim, uppercase registers may be restricted by default, so I
suggest not using them.
</p>

<p class="editorial">
[ Using an uppercase register name appends a 'y'ank or a 'd'elete to the
existing register content; the lowercase version replaces it. -- Ben ]
</p>

<p>
The other registers are special, often storing text, or marks (see below)
for other commands. Therefore these should not be touched. An exception is
the '+' register.
</p>

<p>
Vim's clipboard is independent of the external OS clipboard. Vim imports the text in the OS 
Clipboard into the '+' register. In order to paste something copied into another application 
use the '+' register. Command : <em>"+p</em>
</p>

<p>
As expected, copying or cutting into that register '+' will write to the OS clipboard. 
So if you want to copy something into another program, use <em>"+y</em>
</p>


<h3>Mnemonics</h3>

<p>
Mnemonics are commands to perform common tasks. What separates them from
being normal commands is the underlying ability to remember them from the
task they do. To understand and use mnemonics well, one must first
understand text objects. See <em>:help text-objects</em>, or read the
subsection under "text objects" below. As an example of a mnemonic, take
'<em>ctx</em>':
</p>

<pre>
	ctx - <strong>c</strong>hange <strong>t</strong>ill <strong>x</strong> (deletes from here until first character 'x', and puts you insert mode)
	dtx - <strong>d</strong>elete <strong>t</strong>ill <strong>x</strong> 
</pre>
        

<h4><a name="section_1_10_1_1">Mnemonics that fall under text objects</a></h4>
<p>
There are several objects in vim that act as text-objects: words,
sentences, blocks, etc.. Vim gives you the power to use them in selections
and edits.
</p>

<pre>
        daw - delete a word
        dw - delete from here till end of word
        daW - delete a Word(includes special chars, except space)
        dW - delete from here till end of Word

        das - delete the sentence we are in
        daB - delete an inner Block of code {}
</pre>
<p>
Rules like the above can be applied in general to text objects:
</p>

<pre>
        s - sentence
        w - word
        W - WORD
        t - tag ( 'dat' removes from &lt;xml-style-tag&gt; till &lt;/xml-style-tag&gt;
        p - paragraph
        B - block of code ( '{' or '}' works only for C-style blocks)

        Bracket forms:
                ( or ) - parenthesis ( ... )
                [ or ] - [ .. ]
                &lt; or &gt; - refers to &lt;....&gt;
                { or } - a { block also referred to by the above b

        Quote forms:
                Just like the bracket forms
                ", ', ` - can be used for referring to text-objects delimited by them.
</pre>

<p>
These things can therefore be used in a manner similar to
</p>

<pre>
        da&lt;text-object&gt; : delete a text object
        di&lt;text-object&gt; : delete the inner part of the text object.
        (This leaves the () or the spaces in words or the {} in blocks)
</pre>
<p>
Their use does not end here; remember, vim is intelligent. They can be used
during visual selections as well. In visual mode hit <em>as</em> to select
a sentence. Similarly a word can be selected with <em>aw</em> or a block in
with a '}'.
</p>

<p>
Read <em>:help text-objects</em> for more info.
</p>

<h3>Prefixing Numbers</h3>

<p>
Almost every command can be prefixed with a number to repeat it in a
sensible way. E.g.,
</p>

<pre>
	# Go down 6 lines
	6j
	# Delete the next 10 lines
	10 dd
</pre>

<p>
This is a very underused function that can greatly improve text editing
ease. 
</p>

<h3>Slightly Advanced Navigation</h3>

<h4>Simple Navigation on a line</h4>

<p>
Vim provides you with several one touch commands to get to a particular
character on the line. This coupled with a good use of vim's insertion
techniques should put you where you want with almost no effort.
</p>

<p>
We first learn how to move by words, since moving by characters can often
be slow and demanding.
</p>

<pre>
        <em>(ptca = puts the cursor at)</em>

        w - Takes you a word ahead. ptca the start of the
            next word. ('W' does nearly the same thing, but for "words"
			that may include special characters (excluding 'space'))
        e - ptca the end of this word. If the cursor is already
            under the end of this word, takes you to the end of the next word.
        b - move back a word; ptca the start of the previous
            word
</pre>

<p>
Next, it is important to know how to get to particular positions on a line.
Important places are the start of the line, and the end of the line.
</p>

<pre>
        0 - ptca the start of line
</pre>

<p>
Remember regular expressions? Vim tries to make the learning curve easier.
The following two commands should come naturally if you keep regular 
expressions in mind.
</p>

<pre>
        ^ - ptca the first non-blank character of line
        $ - ptca the end of the line 
</pre>

<p>
The following commands are really useful as well. They let you get to the
nearest instance of a character on a particular line.   
</p>

<pre>
        fx - ptca at the next instance (in the forward direction)
             of character 'x' in the same line.
        Fx - ptca the previous instance of the character
</pre>

<p>
These also form the building blocks whenever generic movement is 
required - like in macros.
</p>

<h4>The g commands</h4>

<p>
The 'g' commands, as I call them, refer to a useful set of 'goto' commands
that ease moving around. Merely stating them should suffice.
</p>

<pre>
        1G - takes you the start of the file
        0G - to the end of file
</pre>
<p>
A good way to remember this is that '1' often appears before (to the left) of '0'
on the number row (above the qwerty row) on a qwerty keyboard.
</p>
<pre> 
        gD - takes you to the first (intelligent) instance of the word under
             the cursor in the same file. It is intelligent, since in a programming
             language, it takes you to the definition or the declaration of the function
             or variable.
        gj - goto next line. (Huh?). This is the same as j when the lines do not wrap.
             When the lines do wrap around the editor, hitting j would take you over to the next
             new line. gj will take you the same character in the next row. (Try it).
        gk - Similar.
        (To avoid wrapping do :set nowrap)
</pre>
<p>
Note indeed that the small 'g' is called the extended operator in vim. It 
performs a lot more than merely goto. Indeed the user can see <em> :help g </em>
 for more information. I'll mention a few useful ones:
</p>

<pre>
		gf - Open the filename under the cursor
		ga - Print ascii value of character under the cursor.
		gs - put vim to sleep for 1 second. Of course, like most
			 vim commands, you can prefix this with a number to get
			 a general sleep command.
</pre>

<h4>Mark Mnemonics</h4>

<p>
Marks are a very useful feature in vim. They enable you to mark your
current position, and move away for a while. You can then go back to the
old cursor position by hitting a couple of keys.
</p>

<pre>
        ma      - mark current position with letter 'a'.
        `a      - go back to mark a
        'a      - put the cursor at the start of line a
        :marks    to see a list of marks made.
</pre>

<p>
Marks are intelligent. Even if you make edits to the text before the mark, thereby
changing its line number or make edits on the line itself (affecting character number),
vim will manage the marks aptly. You will still be able to return to your old mark with
the same key combination. Note that mark movements are often called jumps.
</p>

<p>
There are a few registers that are set by default. I list a few helpful ones below:
</p>

<pre>
        ``      - go back to the last cursor position before a jump.
        `.      - go back to where the cursor the last time an edit was made.
                  This puts your cursor at the start of the edit.
        '(      - go to the start of the current sentence
        ')      - go to the end of the current sentence
        '{      - go to the start of the current paragraph
        '}      - go to the end of the current paragraph
</pre>

<h4>Moving to a line</h4>

<p>
To navigate to line foobar, simply type <em>:foobar</em> or
<em>foobarG</em> . E.g., to navigate line 234:
</p>

<pre>
	:234 
	234G
</pre>

<p>
I strongly recommend using the <em>:number</em>, because you will be able to see the line
number you are typing.
</p>

<p>
As always, remember in vim, if you make a mistake in the middle of a command hit
<em>&lt;Esc&gt;</em>
</p>

<p>
Of course, if you have been there before, and go there frequently enough, I
would suggest marking it. Even though it does not seem that great a
feature, it comes in handy when you have to debug programs.
</p>

<h4>Navigating Screenfulls</h4>
<p>
As mentioned earlier, a design aspect in vim was to allow your hands to stay 
on the home row. So how do you do it without moving your hands to PageUp and
PageDown? 
        
</p>

<pre>
	Control+(f/F)   move forward a screen  (PageDown)
	Control+(b/B)   move backward a screen (PageUp)
	Control+u       moving up half a screen
	Control+d       moving down half a screen
</pre>

<p>
There is one last thing you should know about navigation. In case the line number does not 
show to the bottom left (ruler is set to off), just hit <em>Control+G</em>. This should show you 
the line number and some other statistics in the bottom status bar.
</p>

<h3>Power Keystrokes</h3>

<p>
Think of Power Keystrokes as combos in an arcade-style fighter game. It helps you do several
mundane oft-repeated tasks with a couple of key strokes. The meaning of each of the key
strokes is already known, just like light punches and hard kicks. Putting them together
in specific ways produces several desirable results. We illustrate a few of them to follow.
</p>

<pre>
        xp  - switch the current char and the next
        ddp - switch the current line and the next
        A;  - append a semicolon to the end of the line.
        &gt;&gt;  - increase indent of current line.
        &lt;&lt;  - decrease indent of current line.
</pre>

<h3>Finding and Substituting</h3>

<p>
Finding is a relatively simple job in vim. Just hit '/' in normal mode, and
start typing.  Hit <em>Enter</em> to search.  The key <em>n</em> will take
you to the next search, and <em>Shift+n</em> or <em>N</em> to the previous.
</p>

<p>
A very useful tip when it comes to searching is the '#' key and the '*'
key. These search for the word under the cursor, backwards and forwards
respectively. To sum it up,
</p>

<pre>
        /foobar&lt;Enter&gt;  search for foobar
        n               go to the next result
        N               go to the prev result
        #               search for the word under the cursor (back)
        *               search for the word under the cursor (fwd)
</pre>

<p>
The substitute command is slightly more complicated. However, when in the right hands 
it can prove to be wizardly. The syntax of the substitute command is as follows:
</p>

<pre>
        :[range]s[ubstitute]/pattern/string/[options]
</pre>

<p>
The range is a very interesting argument to play around with. Here we take a look at vim's 
:help range to see what we can do.
</p>

<pre>
        Range           What it means
        ------          --------------
        {number}        an absolute line number
        .               the current line                          
        $               the last line in the file                 
        %               equal to 1,$ (the entire file)            
        *               equal to '&lt;,'&gt; (the Visual area)          
        't              position of mark t (lower case)           
        /{pattern}[/]   the next line where {pattern} matches     
        ?{pattern}[?]   the previous line where {pattern} matches 
        \/              the next line where the previously used search
                        pattern matches
        \?              the previous line where the previously used search
                        pattern matches
        \&amp;              the next line where the previously used substitute
                        pattern matches
</pre>

<p>
Most substitution commands in vim are often written as
<em>:%s/old_string/new_string</em>, for obvious reasons.
</p>

<p>
Again looking into vim's help for the options we get (in brief):
</p>

<pre>
        Option          What it means
        ------          --------------
        c               Ask before substitution. (Check)
        e               Don't cough Error messages if no such pattern is not found.
        g               Global (replace all occurrences in the line).
        i               Ignore case.
        I               Do not ignore case.
        n               Do not substitute. Only return the number of successful matches.
</pre>

<p>
For, e.g., a substitution of the form
</p>

<pre>
        :1,'bs/dog/cat/ceg
</pre>

<p>
would replace dog with cat after checking with you, for all instances in that line, from
line 1 to the line where mark was set as b. It will not throw any errors if 'dog' was not found.
</p>

<p>
See the section on "Dealing with Multiple files" for substituting and searching across 
multiple files.
</p>

<h3>Useful Navigating Techniques for Programmers</h3>

<p>
Even though this could have been fit into the section on navigation above, I decided to make it 
another section to emphasise it further.
</p>

<p>
Vim provides various techniques to the programmer. The most useful one is the jump parenthesis
shortcut.
        
</p>

<pre>
        %       jumps between matching pairs of parenthesis () {} [] &lt;&gt;. With the match-it addon,
                it will jump between matching tags in html files - between the &lt;div ... &gt; and the 
                corresponding &lt;/div&gt;
</pre>

<p>
One might also find the 'goto' command very useful.
</p>

<pre>
	gD      takes you to the global declaration of the variable or function under the cursor.
			However, this will only do so in the same file.

	gF		takes you to the filename under the cursor. Very useful for
			jumping to header files.
</pre>
        
<p>
Vim also integrates with ctags, in a nice and natural way. However, I suggest that you read the help
manual for this.
</p>

<h3>Folds</h3>

<p>
Folds are a wonderful way to organise and group code. Of course, it can be used for editing text,
LaTeX documents, and several other things, but the clarity it gives to code is fascinating.
</p>

<p>
There are several folding methods available in vim. I shall describe only
the manual ones, and briefly mention the rest. More information can be
gotten from <em>:help fold</em> .
</p>

<p>
As with a few other things of this kind, I feel that folds are best
illustrated by an example. Pick a text file, preferably a large one, that
does not fit on one screen. Open it in vim, and place your cursor anywhere
you like. In normal mode, type 
</p>

<pre>
        zf3j 
</pre>

<p>
After you press <em>j</em>, vim will create a fold covering the next 3 lines. How did it happen? Well, <em>zf</em> means
to close a fold, and knowing vim's movements <em>3j</em> is to come down 3 lines. So from the current position to 
3 lines down, vim folds.
</p>

<p>
Vim also supports folding using visual mode. Simply select a piece of text,
and type <em>zf</em>. It should fold as well. Another option is to specify
a range in command mode. For instance, if you wanted to create a fold from
3 lines above to 101th line, you would do 
</p>

<pre>
        :-3, 101 fold 
</pre>

<p>
and hit enter. From 3 lines above to line 101, vim should have folded. Vim
will suitably reverse the range for you if 3 lines above was greater than
101 after prompting. You could have also used markers if necessary.
</p>

<p>
Vim can also make some smart text selections. Suppose you are writing C
code. You can position your cursor on a '{' and hit 
</p>

<pre>
        zfa} 
</pre>

<p>
This will fold till the matching '}'. Of course, as we learnt above you
could also use the more natural 
</p>

<pre>
        zf% 
</pre>

<p>
to perform the same operation. Finally, you can also use a search-fold
technique. You can hit z/ and start typing for the string required. It will
fold from the current line to the first instance it finds the search
string. Therefore, typing in
</p>

<pre>
        z/SearchString
</pre>

<p>
would fold appropriately.
</p>

<p>
Like someone once said, folding is only half the fun. At some point, you'll
no doubt want to unfold the text. To do this, simply place your cursor on
the same line as the fold and type
</p>

<pre>
        zo
</pre>

<p>
This will reopen the fold. This will not delete the fold. Type
</p>

<pre>
        zc
</pre>

<p>
to close it back up when you are finished. To move between various folds quickly, use 
</p>

<pre>
        zj for next fold
        zk for previous fold
</pre>

<h4>Nested folds</h4>

<p>
As said before, vim allows nested folds. If you use <em>zo</em>, it will
open only the first fold; the other folds will stay closed.  The following
commands will prove helpful in dealing with nested folds  
</p>

<pre>
        zO (shift+o)    open all nested folds on that line (<em>zc</em> will close them too)

        zr              open the highest level of folds in the file. For eg, all the first 
                        level folds.
        zR              open all folds of all levels in the file

        zm              close all highest level of open folds in the file.
        zM              close all folds of all levels in the file.

        zE              delete a fold
</pre>

<p>
Delete a fold with caution. vim's undo and redo features don't apply to folds; if you delete a fold, 
you can't press u and bring it back, and the <em>.</em> command won't run the last fold command.
</p>

<p>
How does vim deal with folds when searching for text? It acts as if the fold is not present. If the word
is found while searching within a fold, it will open the fold. Vim is untidy with this. It does not close 
the fold when you move your cursor out. However a quick zm will restore the folds.
</p>

<p>
Once you close the document you created all the folds in, all the folds will be lost. Therefore, you must
ensure to save your folds before you exit. You must also load the saved folds after you open it again. This
can be done with the following commands.
</p>

<pre>
        :mkview         make a foldview
        :loadview 
</pre>
<p>
You can of course automate this by adding the following to your .vimrc:
        
</p><pre>
        au BufWinLeave * mkview
        au BufWinEnter * silent loadview
</pre>
<p>
There exist other folding methods like those mentioned before. Notable ones
are <tt>diff</tt> (via 'vim -d file1 file2'), which set only the edited lines
unfolded, and <tt>indent</tt> which folds depending on indent.
</p>

<h3>Visual mode Selections</h3>

<p>
Visual mode provides what can be called 3 minor modes.
</p>

<pre>
        v       - enters visual mode.
        Shift+v - enters visual mode, where only lines (in full or none) can be selected. 
        Ctrl+v  - enters rectangular visual (block mode).
</pre>

<p>
Play around with these for a while. This should let you become more adept at using Visual. The rectangular
visual mode is very useful in temporarily commenting code, or in removing comments.
</p>

<p>
Suppose we had a code block like
        
</p>

<pre>
        int main()
        {
                register int k;
                ...
                ...
        }
</pre>

<p>
Put your cursor at the start of the main declaration. Hit <em>Ctrl+v</em>
followed by <em>6j</em>. Then hit <em>Shift+i</em> and type
//. Finally hit <em>Esc</em> to come out of the visual mode.
</p>

<p>
This should comment the entire block with C++ style comments.
</p>

<h3>Filters</h3>
<p>
Vim lets you run shell commands from itself by typing 
</p>

<pre>
        :! shell-command
</pre>

<p>
With the concept of a GNU-like "one utility per action" system, the
concept of filters is inevitable. By using a filter, we can send 
text in our buffer (screen) to an external command -
say 'indent' or 'sort' - whose output is then sent back into vim. 
</p>

<p>
Using the range concept given above, one could write things like
</p>

<pre>
        :%!gpg
</pre>

<p>
to encrypt one's message with their personal key. 
</p>

<p>
Here are a couple of other examples
</p>

<pre>
        :%!tr a-z n-za-m (This will ROT13 our data :))

        :.,+5!sort
</pre>

<p>
As mentioned above in the range section, <em>.</em> represents the current line. 
A positive number means below, and a negative number means above.
</p>

<h3>Making Projects</h3>

<p>
With tools like filters learnt above, we could 'make' our projects with commands like
</p>

<pre>
        :!gcc -Wall -g foo.c -o bar
</pre>

<p>
or syntax check them with               
</p>

<pre>
        :!gcc -fsyntax-only % 
</pre>

<p>
Vim however provides its user with a make command. You can set a make program with the
command
</p>

<pre>
        :set makeprg=gcc\ -g\ %
</pre>

<p>
and subsequently make by doing
        
</p>

<pre>
        :make
</pre>

<p>
It accepts command line arguments, enabling you to do things like       
        
</p>

<pre>
        :make all
        :make install
</pre>

<p>
The default <em>makeprg</em> is set to 'make' in the directory vim currently is in. This by default
was the directory our terminal was in, when vim or gvim was called. See the section on 
"Browsing files with Vim" below to find out the current directory and to change it.
</p>

<p>
If there were any errors, vim will display them to you. If you are using a fairly common 
language, vim can even parse the error file and tell you a whole lot more. Pressing 'Enter' 
in the error window should by default take you to the first error.
        
</p>

<p>
In the case the errors can be parsed, the following should be the
holy-grail combinations:
</p>

<pre>
        :cc     -       will show you the current error
        :cn     -       will take you to the next error
        :cN     -       will take you to the prev error
        :copen  -       opens the error window in a small buffer
                        where you can browse errors. Hit &lt;Enter&gt; to be
                        taken to that error.
</pre>

<p>
This should make your compile -&gt;  edit -&gt; compile cycle a lot easier on you.
</p>

<h3>Dealing with Multiple Files</h3>

<p>
Often, programmers or developers have multiple files in their buffers.
I assume you know how to split windows, and all that jazzy stuff. If not,
you could read the Vim tutorial <em>:help vsplit</em> 
</p>

<p>
From vim7.0 onwards, tabs are supported. Tabs can be opened by
        
</p><pre>
        :tabnew file.txt
</pre>

<p>
To cycle through tabs one would use <em>:tabnext</em> (<em>:tabn</em>) and
<em>:tabprevious</em> (<em>:tabp</em>).  One can by default, also go to the
previous/next tab by using <em>Control+PgUp</em> and <em>Control+PgDwn</em>
provided of course there are no other open programs mapped to that
application. (A common program is gnome-terminal with multiple tabs.)
</p>

<p>
Another way to open and edit multiple files is the buffer. Any file you open
is in your buffer till you close it. To open a file in a buffer simply use
the normal edit command 
</p>

<pre>
        :e foo.txt 
</pre>

<p>
For dealing with buffers, one should find the following commands useful:
</p>

<pre>
        :bfirst         switch to the first buffer
        :bn             switch to next buffer
        :bp             switch to prev buffer
        :blast          switch to the last buffer
        :ls             list all currently open buffers
        :buf foo.txt    switch to foo.txt in the buffer
</pre>

<p>
The main power of buffers comes in dealing with them in a batch. Vim has the 
command <tt>bufdo</tt>, which allows you to run a command over all the files in your
buffer.
</p>

<pre>
        :bufdo {cmd}
</pre>

<p>
Quoting the vim Manual,
</p>

<p>
What this basically does is 
</p>

<pre>
        :bfirst
        :{cmd}
        :bnext
        :{cmd}
         etc ...
</pre>

<p>
When the current file can't be abandoned and the [!] is not present, the
command fails.  When an error is detected on one buffer, further buffers
will not be visited.  Unlisted buffers are skipped.  The last buffer (or
where an error occurred) becomes the current buffer.  {cmd} can contain '|'
to concatenate several commands. {cmd} must not delete buffers or add
buffers to the buffer list.
</p>

<p>
To search in multiple files one would simply do
        
</p><pre>
        :bufdo /searchstring/
</pre>

<p>
To search and replace for example, one might do
</p>

<pre>
        :bufdo %s/oldtext/newtext/ge
</pre>

<p>
There are other cool things you could do with buffers. You could backup
your entire project into a tarball by doing something like 
</p>

<pre>
        :silent bufdo !tar -rvf backup.tar %
</pre>

<p>
Of course, the files do not have to be open in vim, you could set the args variable
in vim, and use a similar argdo.
</p>

<p>
For eg. to indent all files in foobar/ one would do
        
</p>

<pre>
        :args foobar/*
        :argdo !indent % | update
</pre>

<p>
update writes the file only if changes were made.
</p>

<h3>Browsing files with Vim</h3>

<p>
Open a directory with 'vim path/to/dir' or from within vim, <em>:e path/to/dir</em>.
A file browser opens up that one can use to browse, and make modifications.
Use <em>&lt;Enter&gt;</em> to enter a directory, and <em>j</em>, <em>k</em> to move up and down.
</p>

<p>
The following should be helpful:
</p>

<pre>
        d - to make a directory
        D - to delete one
        R - to rename
</pre>

<p>
You can set the directory vim is in by using the cd command as
</p>

<pre>
        :cd path/to/dir
</pre>

<p>
As expected you can use <em>:pwd</em> to find out the present directory vim is in.
</p>

<p>
Having the <em>netrw</em> plugin installed, allows one to access and edit files on a remote
machine as well, through protocols like ssh and ftp.
</p>

<h3>Mapping Commands and abbreviations</h3>

<p>
Mapping commands and abbreviations are an essential part of the
programmer's lifeline in vim.
</p>

<p>
Commands can be mapped as follows:
</p>

<pre>
        :map &lt;keystrokes&gt; command-to-be-executed
</pre>

<p>
This will map it in both modes. Use nmap if you want to map it only in the normal mode
and imap for the insert mode.
</p>

<p>
As an example, one might consider
</p>

<pre>
        :nmap \cc !gcc\ -g\ %
</pre>

<p>
This would mean typing <em>\cc</em> (quickly) in the normal mode would execute the gcc compilation
on the current program with debugging enabled.
</p>

<p>
Abbreviations are really useful things to have in one's armory. They let
you substitute a larger word for a smaller one, or fix your common
mistypes. An example should state this clearly enough:
</p>

<pre>
	:iab cs Computer Science.
	:iab mroe more
</pre>

<p>
This would replace 'cs ' (followed by the space) with Computer Science
every time I type it, and replace 'mroe' with 'more'.  The i stands for
insert mode, and the ab for abbreviate. One could do <em>:ab</em> as well,
though it is not recommended. (It might substitute one of your \cs commands
with '\Computer Science'.)
</p>

<p>
To unset the above mapping or abbreviation simply type 
</p>

<pre>
        :unmap \cc  or 
        :unab cs 
</pre>

<p>
respectively.
</p>

<p>
If you want these abbreviations or mappings to remain over various uses of
vim, simply put them in your '~/.vimrc'.
</p>

<p>
As a final example, let us take the remapping of <em>Y</em> to the more
intuitive way of using it.  You would do
</p>
<pre>
        :map Y y$
</pre>
<p>
for this session, and to store it permanently, append
</p>
<pre>
        map Y y$
</pre>
<p>
to your '~/.vimrc'.
</p>

<h2>Macros</h2>
<p>
These are amazingly powerful tools to help you automate your work. It is
like a writing a program to help you do some word processing, without
having to learn another programming language.
</p>

<p>
Imagine the power you'd have if you could write programs with vim
keystrokes to process text. This is precisely what Macros allow you to do.
Macros take a set of keys as input from you and store them in a register of
your choice. (Yes, this is the same set of registers you copy into and
paste from, so don't accidentally overwrite them). You can then run the
command specified by the keys in that register.
</p>

<p>
The syntax for declaring macros is:
</p>

<pre>
        qx&lt;set of commands&gt;q
        (The second q has to be hit in the normal mode only.)
</pre>

<p>
This stores the set of commands in register <em>x</em>. To run it simply type <em>@x</em>. <em>@@</em> runs the last
run macro.
</p>

<p>
Macros are best illustrated with an example. Suppose you have a table, the
field delimiter being ':'. An example is shown below:
</p>

<pre>
        Name    Age     Fav. Animal
        Bob   : 24   :  Duck
        Harry : 18   :  Tiger
        John  : 36   :  Dog
        ...   : ..   :  ....
</pre>

<p>
Suppose the list is very long consisting of 50 or so names. Your job is to extract everybody's
favourite animal and put them in a list. 
</p>

<p>
Of course you could use sed, but you could do it using macros with ease as well. 
To do so you would do the following:
</p>

<ol>
  <li>Put your cursor on Bob, and hit <em>q</em> followed by a register letter say <em>a</em> (for animal)
  </li>
  <li>Type <em>2f:w</em> which should take you to the second cursor, and then to the start of the 
   next word, "Duck".
  </li>
  <li>Yank the word with a <em>yaw</em>. 
  </li>
  <li>We want to move to the end of file, and paste this. However, we should mark our
   position before we leave. Mark it in some register, say <em>f</em>, with <em>mf</em>.
  </li>
  <li>Goto end of file with <em>0G</em>. 
  </li>
  <li>Put in a new line with <em>o</em> and come back to normal mode with <em>&lt;Esc&gt;</em>
  </li>
  <li>paste with <em>p</em>
  </li>
  <li>Go back to the original cursor position with <em>`f</em>
  </li>
  <li>Finally to make the macro repeatable put the cursor at the start of
   the next line, with <em>j0</em> . Exit the macro mode by hitting <em>q</em>.
   </li>
</ol>

<p>
If you now type <em>:regs</em> you will see the following in register <em>a</em>:
</p>

<pre>
        2f:wyawmf0G0^[`fj0
</pre>

<p>(<em>&lt;Esc&gt;</em> has been replaced by <em>^[</em>.)
</p>

<p>
Now to run this macro simply put your cursor on Bob, and do <em>@a</em>. It should perform the
macro and leave you at the beginning of Harry. You can repeat it once again with <em>@@</em> or
simply with a full stop, <em>.</em> (repeat last command). To repeat it several times you could
say 50@@, which would repeat it 50 times.
</p>

<p>
If you found this macro very useful, you could copy it into your .vimrc, replace <em>^[</em> with
<em>&lt;Esc&gt;</em> and map it to a keystroke. As an example, the above macro would transform to 
</p>

<pre>
	" Collect all the animals at the end of the file
	nmap \fa 2f:wyawmf0G0&lt;Esc&gt;`fj0
</pre>

<p>
Macros are terribly underused. Learn to use them effectively.
</p>

<h3>Completion</h3>

<p>
Vim now supports omni-completion as well as intelligent buffer completion.
The following commands should sum this up:
</p>

<pre>
        Ctrl-n - complete (a small popup should appear. You can browse this with
              Ctrl-n and Ctrl-p. Simply continue typing when done.

        Ctrl-x f - complete this filename.

        Ctrl-x i - complete from included files.
</pre>

<h3>SpellCheck</h3>

<p>
With Vim 7.0, Vim now supports built-in spellchecking. To enable it simply
type
</p>

<pre>
        :set spell 
</pre>

<p>
and to disable 
</p>

<pre>
        :set nospell
</pre>

<p>
You can navigate spelling errors by using <em>]s</em> and <em>[s</em> . You can correct them by 
hitting <em>z=</em> . This will pop up a list of possibilities that you can choose from.
</p>

<h3>Common Settings</h3>

<p>
This section simply describes a list of common settings that people might find useful. You can
see <a href="misc/srinivasan/vimrc.txt">my .vimrc</a> to look at what I use.
</p>

<p>
Options are set to true using <em>:set option</em> , unset (set option to
false) using <em>:set nooption</em> and set to other values using <em>:set
option=value</em>. You can invert an true/false option by using <em>:set
invoption</em>. 
</p>

<p>
Options often have shorter names that enable you to type them faster. An
example would be 'ft' for filetype, enabling you to do <em>:set
ft=value</em> instead of the longer <em>:set filteype=value</em>
</p>

<h4>Options</h4>
<pre>
        autoindent  -   automatically indents your cursor on the new line, depending on where 
                        this line started.
        smartindent -   is smarter than autoindent. Knows to go back a tab, if you have closed
                        a block using '{' or goes front a tab if you have opened one with '{'.
                        This is also language specific, and knows the block delimiters for several 
                        languages.
        hlsearch    -   sets highlight of search on or off.
        incsearch   -   sets incremental search on or off. Incremental search is the name 
                        programmers give to "find as you type" search. This is VERY useful.
        expandtab   -   fill tabs with spaces when a tab is hit. The number of spaces depends on 
                        the tabstop option.
        showmatch   -   show matching (), {}, [] when typing. Very useful for programmers.
        ft=VALUE    -   set filetype = VALUE
</pre>

<p>
As an example you could do
</p>

<pre>
        :set hlsearch           switches hlsearch on
        :set nohlsearch         switches hlsearch to off
        :set invhlsearch        inverts hlsearch (which was previously off due to the last
                                command) to on.
</pre>

<p>
To change file types from 'txt' to 'html' you would do
</p>

<pre>
        :set ft=html
</pre>
        
<p>
and if you still find no syntax highlighting,
</p>

<pre>
        :enable syntax
        # or
        :syntax on
</pre>
        
<p>
For help on an option, do <em>:help option</em>
</p>

<p>
There is a very useful option that I often use. I am one of those compulsive <em>&lt;Esc&gt;</em> hitters.
If I am decide to change my command, or abort my command, or simply feel itchy I hit the &lt;Esc&gt;
button (often more than once). Vim deals with it graciously, and simply beeps, which does not
bother me at all. However, in a work situation like the office or the lab, people sitting near
you may get irritated with the beep(s). You can tell vim to switch off the sound alert, and
switch on a visual one with
</p>

<pre>
        :set visualbell
</pre>

<p>
Try hitting two <em>&lt;Esc&gt;</em>'s in a row now. The screen should just flash.
</p>

<h3>Miscellaneous Commands</h3>
<p>
This section lists a few miscellaneous commands that would not fit anywhere else in this document.
        
</p>

<pre>
        Shift+j (or J) - This will bring up the next line and join it to the end of the current one.
		                 Learn to use this well. It is what people in other editors would perform as 
                         &lt;End&gt;&lt;Del&gt; . A mnemonic for Join the previous line with current line.

        Shift+k (or K) - Displays the man page for word under cursor

        ~              - Swap Case of character under cursor, and move to the next character.

        .              - repeat the last command, whatever it is. (The command could be the insertion of a
                         sentence or even a macro). What most editors would call 'repeat'.
</pre>

<p>
Vim can also increment and decrement numbers for you. This is extremely
useful in writing larger more generic macros. As usual, numbers prefixed
with a '0' are considered octal; numbers prefixed with a '0x' are
considered hexadecimal. Numbers not beginning with a zero, are decimal.
</p>

<pre>
        Control+A      - Increments the number under the cursor
        Control+X      - Decrements the number under the cursor
</pre>

<h3>Useful Plugins</h3>
<p>
Vim, much like Emacs is an extensible editor. There are thousands of plugins for vim, that make one's
life a lot easier. Purely for completeness, I list some of the more popular plugins here
</p>

<pre>
        taglist explorer        opens a wonderful little function list by your side,
                                just like an IDE

        matchit                 enables matching of regular expressions using %

        gpg                     encrypts your data with with your private key. Performs
                                decryption as well. 

        calendar                displays a calendar in your vim window, to which you can
                                add notes, et al, ala org-mode

        minibufexplorer         displays all open buffers and tabs on a horizontal list at
                                the top/bottom of your screen.

        tetris                  yes, with rotating game play and high scores!
</pre>
  
<p>
Besides all this, there are a lot of programming suites available for the more popular languages
like C/C++, LaTeX, Java, Python, Ruby, etc...
</p>

<p>
There are currently more than 2200 plugins available at <a
href="http://vim.org">http://vim.org</a>, some of which are bound to make
your life easier or a little more fun. Taking advantage of such a wealth of
hard work and talent is more than just good fun; it makes a lot of sense.
</p>

<h2><a>Final Tips</a></h2>
<p>
When all said and done, it is up to you to become proficient in using vim.
There is no harm in thinking out what is the best way to do something when
you do it for the first time. It will save a lot of time in the future. At
one point of time, all efficient vim users thought about the commands they
were typing. Reflect on it, before it becomes a habit. It might be slow
initially, but the effects you reap later on will be very high.
</p>

<p>
If you are the kind who keeps forgetting which mode insert/normal/visual
mode you are in, remember, as mentioned before that vim is meant to be kept
in the normal mode. Words are to be inserted in short bursts. As soon as
you finish typing/selecting, come back to normal mode, by hitting
<em>&lt;Esc&gt;</em>.
</p>

<p>
Also, remember that vim commands can be repeated by prefixing numbers to
the commands. Like <em>7j</em> or <em>3w</em>, etc.. This is probably the
most underused vim powertool. Write macros that can be repeated too.
</p>

<p>
Finally, remember to customise your .vimrc with useful functions, macros,
abbreviations, and settings.  Before hurriedly writing your own plugin,
search vim.org. There are lots of plugins that can help improve daily
productivity. And yes, do remember that vim's <em>:help</em> is a wonderful
piece of documentation.
</p>

<p>
Good Luck Vimming!
</p>



<script type='text/javascript'>
digg_url = 'http://linuxgazette.net/152/srinivasan.html';
digg_title = 'A slightly advanced Introduction to Vim';
digg_bodytext = '<p> This introduction is about the little things. Things that help ease everyday tasks but go a  long way into making you a better user, editor, programmer - a better computer user. </p> ';
digg_topic = 'linux_unix';
</script>
<script src="http://digg.com/tools/diggthis.js" type="text/javascript"></script>


<p class="talkback">
Talkback: <a
href="mailto:tag@lists.linuxgazette.net?subject=Talkback:152/srinivasan.html">Discuss this article with The Answer Gang</a>
</p>

<!-- *** BEGIN author bio *** -->
<hr>
<p>
<img align="left" alt="[BIO]" src="../gx/authors/srinivasan.jpg" class="bio">
</p>

<em>
<p>
Pranesh Srinivasan is currently pursuing a B. Tech (and subsequently, an
 M. Tech) in Computer Science and Engineering at the <a
 href="http://www.iitm.ac.in">Indian Institute of Technology Madras</a>.
 He has been using GNU/Linux for the last two years.
</p>

<p>
Initiated into Linux by laboratories in his department, he switched
 voluntarily to GNU/Linux soon after, realising the potential power and
 control it could give him. Apart from loving to script in python, he
 loves using vim, LaTeX, perl, git, and Gnome. He dual boots his personal
 machine with Debian GNU/Linux and Ubuntu GNU/Linux.
</p>

<p>
His other interests include writing, reading, swimming, playing
 football, and general mathematics.
</p>



</em>

<br clear="all">


<!-- *** END author bio *** -->

<div id="articlefooter">

<p>
Copyright &copy; 2008, Pranesh Srinivasan. Released under the <a
href="http://linuxgazette.net/copying.html">Open Publication License</a>
unless otherwise noted in the body of the article. Linux Gazette is not
produced, sponsored, or endorsed by its prior host, SSC, Inc.
</p>

<p>
Published in Issue 152 of Linux Gazette, July 2008
</p>

</div>

<div id="previousnextbottom">
<A HREF="ramanathan.html" >&lt;-- prev</A> | <A HREF="collinge.html" >next --&gt;</A>
</div>

</div>
</div>

<script src="http://www.google-analytics.com/urchin.js"
type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1204316-1";
urchinTracker();
</script>







<img src="../gx/tux_86x95_indexed.png" id="tux" alt="Tux"/>

</body>
</html>

